#!/usr/bin/env python3

"""Provide functionality relating to an application dock

Manage a list of pinned and non-pinned dock apps.

Handle all mouse ui events for docked apps
Respond to window opening and closing events from libwnck
Respond to changes to the Gtk icon theme and update all docked apps
Load and save dock settings (e.g. pinned apps and indicator type)

respond to selections made in the applet right click menu, specifically
    : allow apps to be pinned to the dock
    : allow apps to unpinned from the dock
    : allow app icons be to moved to a different position on the dock
    : disply an About dialog
    : display a Preferences dialog
"""

# Copyright (C) 1997-2003 Free Software Foundation, Inc.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; either version 2 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301, USA.
#
# Author:
#     Robin Thompson

import gi
gi.require_version("Gtk", "2.0")
gi.require_version("MatePanelApplet", "4.0")
from gi.repository import Gtk
from gi.repository import Gdk
from gi.repository import MatePanelApplet
from gi.repository import GObject

gi.require_version("Wnck", "1.0")
from gi.repository import Wnck

from gi.repository import GdkPixbuf
from gi.repository import Gio
from gi.repository import GLib
import os
import os.path
import sys
from time import sleep

import docked_app
import dock_prefs
import dock_about
import dock_custom_launcher
import dock_win_list
import dock_xml
import dock_color_changer
import dock_info

from log_it import log_it as log_it

class Dock(object):
    """The main application dock class

        Attributes:
            applet : the MATE panel applet
            wnck_screen : the currently active wnck_screen. Assumed to be the default
                          wnck_screen on applet start up
            window :
            app_list : the list of DockedApp objects. Will contain running/non-running
                       pinned apps and running unpinned apps
            box    : A Gtk HBox or VBox (depending on the applet orientation) containing
                     the drawing areas of each of the app in app_list
            icontheme : used to load application icons and detect changes in the icon theme
            about_win : the about window
            prefs_win : the preferences window
            ccl_win   : the create custom launcher window
            app_with_mouse : the DockedApp that the mouse is currently over
            active_app : the DockedApp that is currently the foreground app
            right_clicked_app: the app that was most recently right clicked
            settings_path : the GIO.Settings path for the applet
            settings : GIO.Settings - the settings for the applet
            indicator : the indicator type (light or dark, or None)
            multi_ind : whether or not multiple indicators are to be used
            show_all_apps : whether or not unpinned apps from all workspaces
                                     are displayed in the dock
            win_from_cur_ws_only : whether indicators and window list items are to be shown
                                   for the current workspace only
            change_panel_color : whether or not the color of MATE panels are to be
                                 changed to the dominant colour of the desktop wallpaper
            change_dock_color_only : whether or not all MATE panels are to have their colour
                                     changed or just the panel containing the dock
            panel_id : the toplevel id of the panel the applet is on
            dock_action_group : Gtk Action group containing all of the actions
                                for the applet right click menu
            app_win_list : a replacement for the default tooltip - a window which lists
                           the currently highlighted  app's open windows and allows the
                           user to select one
            win_list_delay : the amount of time (in milliseconds) after which the app's
                             window list will pop up when the mouse hovers over the app
            win_list_timer : timer object used to cound win_list_delay
            panel_cc : used to changed to the colour of the MATE panel(s) to the dominant
                      color of the desktop wallpaper (if enabled in the applet settings)

    """

    def __init__(self, applet):
        """Init the Dock.

        Load settings
        Setup the applet right click menu and actions
        Set default values
        """

        super().__init__()

        self.applet = applet    # the panel applet, in case we need it later

        self.app_list = []
        self.box = None
        self.icontheme = Gtk.IconTheme.get_default()
        self.icontheme.connect("changed", self.icon_theme_changed)

        self.window = None

        self.wnck_screen = Wnck.Screen.get_default()

        self.app_with_mouse = None      # the dock app that mouse is currently over
        self.active_app = None          # the currently active app
        self.right_clicked_app = None     # the app that most recently had a right click

        self.settings_path = self.applet.get_preferences_path()
        self.settings = Gio.Settings.new_with_path("org.mate.panel.applet.dock", \
                                                    self.settings_path)

        # instantiate these - will be set up later
        self.object_settings = ""
        self.panel_id = ""

        # specify the xml file to be used as an alternative storage location for the
        # applet settings
        self.xml_conf=os.path.expanduser("~/.config/mate_dock_applet.conf")

        self.prefs_win = None
        self.about_win = None
        self.ccl_win = None
        self.indicator = 0
        self.multi_ind = False
        self.show_all_apps = True
        self.win_from_cur_ws_only = False
        self.click_restore_last_active = True
        self.change_panel_color = False
        self.change_dock_color_only = False
        self.read_settings()

        # read the list of apps which are difficult to match with their .desktop files
        self.app_match = self.read_app_match()
        self.dock_action_group = None

        self.app_win_list  = dock_win_list.DockWinList(self.wnck_screen)
        self.app_win_list.icontheme = self.icontheme
        self.win_list_delay = 500
        self.win_list_timer = None

        # create an event handler so that we can react to changes e.g
        # the panel the applet is on, or it's position on the panel
        applet_spath = self.settings_path[0: len(self.settings_path)-6] # remove "prefs/" suffix
        self.object_settings = Gio.Settings.new_with_path("org.mate.panel.object", applet_spath)
        self.object_settings.connect("changed", self.panel_settings_changed)

        self.setup_menu()

        self.panel_cc = dock_color_changer.PanelColorChanger()

        # instantiate a timer to perform further setup once the applet has been fully
        # created
        GObject.timeout_add(1000, self.do_delayed_setup)

    def do_delayed_setup(self):
        """ Perform setup operations that we couldn't do until the dock was fully
            instantiated

            Get the id of the panel the applet is on
            Do the initial panel colour change (if necessary)
        """

        self.get_panel_id()

        # now that we have our panel id, we can set use it to set to panel colour changer
        # if necessary
        if self.change_dock_color_only:
            self.panel_cc.set_single_panel(self.panel_id)
        else:
            self.panel_cc.set_single_panel("")

        # enable panel colour changing?
        if self.change_panel_color:
            self.panel_cc.enable_color_change()
            self.panel_cc.do_change_panel_color() # we're starting up so need to do an initial panel
                                                  # colour change

        return False        # cancel the timer

    def get_panel_id(self):
        """ Get the toplevel id of the panel the applet is on
        """

        # get the info from dconf settings
        self.panel_id = self.object_settings.get_string("toplevel-id")


    def panel_settings_changed(self, settings, key):
        """ Callback for when the the applet settings with regards to it's panel are
            changed

            If the panel the applet is on is changed, update our panel id and
            recalculate all docked apps minimize positions accordingly

            If the appllet's position on its panel is changed, the minimize
            positions of all docked apps also need to be minimized
        """

        if key == "toplevel-id":
            self.get_panel_id()
            if self.change_dock_color_only:
                self.panel_cc.set_single_panel(self.panel_id)
            self.set_app_minimise_targets()
            pass

        if key == "position":
            self.set_app_minimise_targets()
            pass


    def read_settings(self):
        """ Read the current dock settings from dconf

            If this particular dock has not been run before and a settings files does not exist
            (i.e. the dock applet has never been run before) show the hints and tips dialog

            Otherwise, If this particular dock has not been run before and a settings xml file
            exists offer to import the settings from the xml file ...

        """

        # is this dock being run for the first time?
        if self.settings.get_boolean("first-run") == True:

            if not (os.path.isfile(self.xml_conf)):
                # we don't have a saved settings file, so show the hints and tips dialog
                # but delay its appearance slightly..

            # this dock is being run for the first time, so if we have any saved settings
            # from other docks, import them. Note: prior to V0.70 the applet presented a
            # dialog asking the user whether or not to import the previous settings.
            # The is dialog has been removed and the previous settings are now silently
            # imported to prevent problems when swtiching to the Mutiny layout in Ubuntu
            # Mate 16.04

            xml_settings = dock_xml.read_xml(self.xml_conf)

            if xml_settings[0] == True:
                # the settings were read correctly, so set everything up

                pinned_apps = []
                for pinned_app in xml_settings[1]:
                    pinned_apps.append(pinned_app)

                self.indicator = xml_settings[2]
                self.show_all_apps = xml_settings[3]
                self.multi_ind = xml_settings[4]
                self.click_restore_last_active = xml_settings[5]
                self.win_from_cur_ws_only = xml_settings[6]
                self.change_panel_color = xml_settings[7]
                self.change_dock_color_only = xml_settings[8]

                # now, immediately write the settings to dconf and back to the config file
                # so the dock can access them

                self.settings.set_value("pinned-apps", GLib.Variant('as', pinned_apps))
                self.settings.set_int("indicator-type", self.indicator)
                self.settings.set_boolean("multi-ind", self.multi_ind)
                self.settings.set_boolean("apps-from-all-workspaces", self.show_all_apps)
                self.settings.set_boolean("first-run", False)
                self.settings.set_boolean("click-restore-last-active", self.click_restore_last_active)
                self.settings.set_boolean("win-from-cur-workspace-only", self.win_from_cur_ws_only)
                self.settings.set_boolean("change-panel-color", self.change_panel_color)
                self.settings.set_boolean("change-panel-color-dock-only", self.change_dock_color_only)

                dock_xml.write_xml(self.xml_conf, pinned_apps, self.indicator, \
                        self.show_all_apps, self.multi_ind, self.click_restore_last_active, \
                        self.win_from_cur_ws_only, \
                        self.change_panel_color, self.change_dock_color_only)

                return

        # we get here if there was no previous configuration, or the configuration couldn't be read.
        # Where the configuration cou;n't be read this could be due to an error or because new versions
        # of the applet have added configuration options not yet in the user's xml file. To recover,
        # simply  assume a default set of options
        self.indicator = self.settings.get_int("indicator-type")
        self.multi_ind = self.settings.get_boolean("multi-ind")
        self.show_all_apps = self.settings.get_boolean("apps-from-all-workspaces")
        self.win_from_cur_ws_only = self.settings.get_boolean("win-from-cur-workspace-only")
        self.click_restore_last_active = self.settings.get_boolean("click-restore-last-active")
        self.change_panel_color = self.settings.get_boolean("change-panel-color")
        self.change_dock_color_only = self.settings.get_boolean("change-panel-color-dock-only")


    def write_settings(self):
        """Write the current dock settings.

        Write a list of all of the currently pinned apps .desktop files
        Write the indicator type, whether to use multiple indicators,
        and whether to show unpinned apps from all workspaces

        Set the first-run indicator to False
        """

        pinned_apps = []
        for dock_app in self.app_list:

            if (dock_app.desktop_file is not None) and (dock_app.is_pinned):
                pinned_apps.append(os.path.basename(dock_app.desktop_file))

        if self.settings:
            self.settings.set_value("pinned-apps", GLib.Variant('as', pinned_apps))
            self.settings.set_int("indicator-type", self.indicator)
            self.settings.set_boolean("multi-ind", self.multi_ind)
            self.settings.set_boolean("apps-from-all-workspaces", self.show_all_apps)
            self.settings.set_boolean("win-from-cur-workspace-only", self.win_from_cur_ws_only)
            self.settings.set_boolean("click-restore-last-active", self.click_restore_last_active)
            self.settings.set_boolean("change-panel-color", self.change_panel_color)
            self.settings.set_boolean("change-panel-color-dock-only", self.change_dock_color_only)
            self.settings.set_boolean("first-run", False)

        dock_xml.write_xml(self.xml_conf, pinned_apps, self.indicator, \
                           self.show_all_apps, self.multi_ind, self.click_restore_last_active,
                           self.win_from_cur_ws_only,
                           self.change_panel_color,
                           self.change_dock_color_only)


    def read_app_match(self):
        """ Read an xml file which contains a list of apps which are difficult to match with
            their respective .desktop file.

        Returns:
            A list of tuples which containing the following:
                the app name (as reported by wnck)
                the app's wm_class (as reported by wnck)
                the .desktop file to be used by apps whose name or wm_class match the above
        """

        d, f = os.path.split(os.path.abspath(__file__))
        results = dock_xml.read_app_xml("%s/app_match.xml" %d)
        if results[0]:
            # the file was read successfully
            return results[1]
        else:
            return []

    def set_actions_for_app(self, app):
        """Show or hide actions in the context menu so that only relevant ones are
           shown for the specified app

           If the app is pinned, do not show the pin action.

           If the app in not pinned, don't show the unpin action.

           Depending on applet orientation actions to move the app left/right
           or up/down along the dock need to shown or hidden.

           If the app is the first or last on the dock, then the options to
           move it up/left or down/right will also need to be hidden

           Include the app name in the menu text e.g. Pin Caja to the dock

           If the app has more than one window on screen, show actions allowing
           the user to select one

           If the app is running and has one or more windows on screen, show
           an option allowing them to be closed

           If the app does not have a desktop file, show an option allowing a
           custom launcher to be created

           Show any right click options specified in the app's desktop file

        Args:
            app : The DockedApp
        """

        df_shortcut_1_action = self.dock_action_group.get_action("df_shortcut_1_action")
        df_shortcut_2_action = self.dock_action_group.get_action("df_shortcut_2_action")
        df_shortcut_3_action = self.dock_action_group.get_action("df_shortcut_3_action")
        df_shortcut_4_action = self.dock_action_group.get_action("df_shortcut_4_action")

        act_exists, act_name, act_cmd_line = app.get_rc_action(1)
        df_shortcut_1_action.set_visible(act_exists)
        if act_exists == True:
            df_shortcut_1_action.set_label(act_name)
            df_shortcut_1_action.set_icon_name(app.icon_name)

        act_exists, act_name, act_cmd_line = app.get_rc_action(2)
        df_shortcut_2_action.set_visible(act_exists)
        if act_exists == True:
            df_shortcut_2_action.set_label(act_name)
            df_shortcut_2_action.set_icon_name(app.icon_name)

        act_exists, act_name, act_cmd_line = app.get_rc_action(3)
        df_shortcut_3_action.set_visible(act_exists)
        if act_exists == True:
            df_shortcut_3_action.set_label(act_name)
            df_shortcut_3_action.set_icon_name(app.icon_name)

        act_exists, act_name, act_cmd_line = app.get_rc_action(4)
        df_shortcut_4_action.set_visible(act_exists)
        if act_exists == True:
            df_shortcut_4_action.set_label(act_name)
            df_shortcut_4_action.set_icon_name(app.icon_name)

        pin_action = self.dock_action_group.get_action("pin_action")
        unpin_action = self.dock_action_group.get_action("unpin_action")
        move_up_action = self.dock_action_group.get_action("move_up_action")
        move_down_action = self.dock_action_group.get_action("move_down_action")
        move_left_action = self.dock_action_group.get_action("move_left_action")
        move_right_action = self.dock_action_group.get_action("move_right_action")

        close_win_action = self.dock_action_group.get_action("close_win_action")
        close_win_action.set_visible(False)

        index = self.get_app_position_in_dock(app)
        pin_action.set_visible(not app.is_pinned)
        unpin_action.set_visible(app.is_pinned)

        orientation = self.applet.get_orient()

        if orientation == MatePanelApplet.AppletOrient.LEFT or \
           orientation == MatePanelApplet.AppletOrient.RIGHT:
            move_up_action.set_visible(index > 0)
            move_down_action.set_visible(index < (len(self.box.get_children()))-1)
            move_left_action.set_visible(False)
            move_right_action.set_visible(False)
            move_up_action.set_label("Move %s up the dock" %app.app_name)
            move_down_action.set_label("Move %s down the dock" %app.app_name)
        else:
            move_up_action.set_visible(False)
            move_down_action.set_visible(False)
            move_left_action.set_visible(index > 0)
            move_right_action.set_visible(index < (len(self.box.get_children()))-1)
            move_left_action.set_label("Move %s to the left on the dock" %app.app_name)
            move_right_action.set_label("Move %s to the right on the dock" %app.app_name)

        if pin_action.is_visible():
            pin_action.set_label("Pin %s to the dock" %app.app_name)
        else:
            unpin_action.set_label("Unpin %s from the dock" %app.app_name)

        # set the actions for selecting specific windows

        num_win = app.get_num_windows()
        if num_win == 1:
            close_win_action.set_label("Close %s" %app.app_name)
        else:
            close_win_action.set_label("Close all windows")

        if num_win > 0:
            close_win_action.set_visible(True)

        ccl_action = self.dock_action_group.get_action("ccl_action")
        ccl_action.set_visible(not app.has_desktop_file())


    def setup_menu(self):
        """Set up the actions and right click menu for the applet
        """

        # actions named df_shortcut_<x>_action are used for implementing shortcuts/actions
        # specified in an app's .desktop file

        self.dock_action_group = Gtk.ActionGroup("DockActions")
        self.dock_action_group.add_actions([
                            ("df_shortcut_1_action", None,
                             "df_shortcut_1_action", None, "df_shortcut_1_action",\
                             self.df_shortcut_1), \
                            ("df_shortcut_2_action", None,
                             "df_shortcut_2_action", None, "df_shortcut_2_action",\
                             self.df_shortcut_2), \
                            ("df_shortcut_3_action", None,
                             "df_shortcut_3_action", None, "df_shortcut_3_action",\
                             self.df_shortcut_3), \
                            ("df_shortcut_4_action", None,
                             "df_shortcut_4_action", None, "df_shortcut_4_action",\
                             self.df_shortcut_4), \
                             ("pin_action", Gtk.STOCK_ADD, \
                             "_Pin app to the dock", None, "Pin app to the dock", \
                             self.pin_app), \
                             ("unpin_action", Gtk.STOCK_REMOVE, \
                             "_Unpin app from the dock", None, "Unpin app from the dock", \
                             self.unpin_app), \
                             ("move_up_action", Gtk.STOCK_GO_UP,\
                             "Move app _up the dock", None, "Move app up the dock", \
                             self.move_app_up), \
                             ("move_down_action", Gtk.STOCK_GO_DOWN, \
                             "Move app _down the dock", None, "Move app down the dock", \
                             self.move_app_down), \
                             ("move_left_action", Gtk.STOCK_GO_BACK,\
                             "Move app _left in the dock", None, "Move app left in the dock",\
                             self.move_app_up), \
                             ("move_right_action", Gtk.STOCK_GO_FORWARD, \
                             "Move app _right in the dock", None, "Move app right in the dock",\
                             self.move_app_down), \
                             ("prefs_action", Gtk.STOCK_PREFERENCES, \
                             "Dock P_references", None, "Dock Preferences", \
                             self.show_prefs_win), \
                             ("ccl_action", Gtk.STOCK_EXECUTE, \
                             "Create custo_m launcher for this app", None, "Create custom launcher for this app", \
                             self.show_ccl_win), \
                             ("about_action", Gtk.STOCK_ABOUT, \
                             "About...", None, "About...", self.show_about_win), \
                             ("close_win_action", Gtk.STOCK_CLOSE, \
                              "_Close", None, "Close", self.close_win) \
                             ])

        menu_xml = '<menuitem name="df_shortcut_1_action" action="df_shortcut_1_action"/><separator/>'
        menu_xml += '<menuitem name="df_shortcut_2_action" action="df_shortcut_2_action"/><separator/>'
        menu_xml += '<menuitem name="df_shortcut_3_action" action="df_shortcut_3_action"/><separator/>'
        menu_xml += '<menuitem name="df_shortcut_4_action" action="df_shortcut_4_action"/><separator/>'
        menu_xml += '<menuitem name="close_win" action="close_win_action"/><separator/>'
        menu_xml += '<menuitem name="move_up" action="move_up_action"/>'
        menu_xml += '<menuitem name="move_down" action="move_down_action"/>'
        menu_xml += '<menuitem name="move_left" action="move_left_action"/>'
        menu_xml += '<menuitem name="move_right" action="move_right_action"/>'
        menu_xml += '<separator/><menuitem name="Pin" action="pin_action"/>'
        menu_xml += '<menuitem name="Unpin" action="unpin_action"/><separator/>'
        menu_xml += '<menuitem name="Preferences" action="prefs_action"/>'
        menu_xml += '<menuitem name="Create custom launcher" action="ccl_action"/>'
        menu_xml += '<menuitem name="About" action="about_action"/><separator/>'

        self.applet.setup_menu(menu_xml, self.dock_action_group)

    def df_shortcut_1(self, data=None):
        """Perform the app's 1st .desktop file specified shortcut/action
        """

        if self.right_clicked_app is not None:
            self.right_clicked_app.run_rc_action(1)

    def df_shortcut_2(self, data=None):
        """Perform the app's 1st .desktop file specified shortcut/action
        """

        if self.right_clicked_app is not None:
            self.right_clicked_app.run_rc_action(2)

    def df_shortcut_3(self, data=None):
        """Perform the app's 1st .desktop file specified shortcut/action
        """

        if self.right_clicked_app is not None:
            self.right_clicked_app.run_rc_action(3)

    def df_shortcut_4(self, data=None):
        """Perform the app's 1st .desktop file specified shortcut/action
        """

        if self.right_clicked_app is not None:
            self.right_clicked_app.run_rc_action(4)

    def unpin_app(self, data=None):
        """Unpin the right clicked app from the dock.

        Unpin the app and update the dock settings.

        If the app is not running, remove it from the dock also
        """

        if self.right_clicked_app is not None:
            self.right_clicked_app.is_pinned = False
            self.write_settings()
            if not self.right_clicked_app.is_running():
                self.remove_app_from_dock(self.right_clicked_app)
                self.right_clicked_app = None

    def pin_app(self, data=None):
        """Pin the right clicked app to the dock.

        Pin the app and update the dock settings"""

        if self.right_clicked_app is not None:
            self.right_clicked_app.is_pinned = True
            self.write_settings()

    def get_app_position_in_dock(self, app):
        """ Get the position of a specified app in the dock.

        Args : app - A DockedApp

        Returns : the index of the app, or -1 if it wasn't found
        """

        index = 0
        for app_da in self.box.get_children():
            if app_da == app.drawing_area:
                return index
            index += 1

        return -1

    def move_app_up(self, data=None):
        """ Move the right clicked app up one position on the dock (or left if the
            panel is on the top or bottom of the screen).

        Moves the app and then recaculates the minimize location for it's windows.

        Writes the dock settings once all is done.
        """

        if self.right_clicked_app is not None:

            index = self.get_app_position_in_dock(self.right_clicked_app)
            if index > 0:

                # we need to move the app both in self.applist and self.box
                self.box.reorder_child(self.right_clicked_app.drawing_area, index-1)

                app = self.app_list[index-1]
                self.app_list[index-1] = self.app_list[index]
                self.app_list[index] = app

                # recalculate the minimize targets for each app
                self.app_list[index-1].set_icon_geometry()
                self.app_list[index].set_icon_geometry()

                self.write_settings()

    def move_app_down(self, data=None):
        """ Move the right clicked app down one position on the dock (or right if the
            panel is on the top or bottom of the screen).

        Moves the app and then recaculates the minimize location for it's windows.

        Writes the dock settings once all is done.
        """

        if self.right_clicked_app is not None:

            index = self.get_app_position_in_dock(self.right_clicked_app)
            if index < len(self.box.get_children()) -1:

                # we need to move the app both in self.applist and self.box
                self.box.reorder_child(self.right_clicked_app.drawing_area, index+1)

                app = self.app_list[index+1]
                self.app_list[index+1] = self.app_list[index]
                self.app_list[index] = app

                # recalculate the minimize targets for each app
                self.app_list[index+1].set_icon_geometry()
                self.app_list[index].set_icon_geometry()

                self.write_settings()

    def show_prefs_win(self, data=None):
        """ Show the preferences window.

        If, necessary create the window and register a callback for the 'ok' button
        press

        If the window has already been shown, just show it again.
        """

        if self.prefs_win is None:
            self.prefs_win = dock_prefs.DockPrefsWindow(self.prefs_win_ok_cb)
            self.prefs_win.set_indicator(self.indicator)
            self.prefs_win.set_multi_ind(self.multi_ind)
            self.prefs_win.set_show_unpinned_apps_on_all_ws(self.show_all_apps)
            self.prefs_win.set_win_cur_ws_only(self.win_from_cur_ws_only)
            self.prefs_win.set_click_restore_last_active(self.click_restore_last_active)
            self.prefs_win.set_change_panel_color(self.change_panel_color)
            self.prefs_win.set_change_dock_color_only(self.change_dock_color_only)
        else:
            self.prefs_win.show_all()

    def show_about_win(self, data=None):
        """ Show the About window.

        If, necessary create the window and show it.

        If the window has already been shown, just show it again.
        """
        if self.about_win is None:
            self.about_win = dock_about.AboutWindow()

        self.about_win.show_all()

    def prefs_win_ok_cb(self, widget, event):
        """ Callback for the 'ok' button on the preferences window.

        If the preferences have been changed then:
            write the new settings
            redraw each running app in app_list with the new indicator type

        Args:
            widget - the button the caused the event
            event - the event args
        """
        if (self.indicator != self.prefs_win.get_indicator_type()) or \
           (self.multi_ind != self.prefs_win.get_multi_ind()) or \
           (self.show_all_apps != self.prefs_win.get_show_unpinned_apps_on_all_ws()) or \
           (self.win_from_cur_ws_only != self.prefs_win.get_win_cur_ws_only()) or \
           (self.click_restore_last_active != self.prefs_win.get_click_restore_last_active()) or \
           (self.change_panel_color != self.prefs_win.get_change_panel_color()) or \
           (self.change_dock_color_only != self.prefs_win.get_change_dock_color_only()):

            self.indicator = self.prefs_win.get_indicator_type()
            self.multi_ind = self.prefs_win.get_multi_ind()
            self.show_all_apps = self.prefs_win.get_show_unpinned_apps_on_all_ws()
            self.win_from_cur_ws_only = self.prefs_win.get_win_cur_ws_only()
            self.click_restore_last_active = self.prefs_win.get_click_restore_last_active()

            new_panel_color_setting = self.change_panel_color != self.prefs_win.get_change_panel_color()
            self.change_panel_color = self.prefs_win.get_change_panel_color()

            self.change_dock_color_only = self.prefs_win.get_change_dock_color_only()
            if self.change_dock_color_only:
                self.panel_cc.set_single_panel(self.panel_id)
            else:
                self.panel_cc.set_single_panel("")

            self.write_settings()

            # redraw everything here
            for app in self.app_list:
                app.set_indicator(self.indicator)
                app.set_multi_ind(self.multi_ind)
                if app.is_running():
                    app.queue_draw()
            self.show_or_hide_app_icons()
            self.show_or_hide_indicators()

            if new_panel_color_setting:
                # panel colour changing setting has been changed so we need to
                # enable or disable colour changing
                if self.change_panel_color:
                    self.panel_cc.enable_color_change()
                    self.panel_cc.do_change_panel_color()
                else:
                    self.panel_cc.disable_color_change()

        self.prefs_win.hide()

    def show_ccl_win(self, data=None):
        """ Show the create custom launcher window.

        If, necessary create the window and register a callback for the 'ok' button
        press

        If the window has already been shown, clear all of the fields
        before showing it
        """

        if self.ccl_win is None:
            self.ccl_win = dock_custom_launcher.DockCLWindow(self.ccl_win_ok_cb)
        else:
            self.ccl_win.set_default_values()

        self.ccl_win.name = self.right_clicked_app.app_name.strip()
        self.ccl_win.wm_class = self.right_clicked_app.wm_class_name
        self.ccl_win.show_all()

    def ccl_win_ok_cb(self, widget, event):
        """ Callback for the 'ok' button on the create custom launcher window.

        Check to ensure that all required fields (icon, launcher name and command) have been
        entered and display an error dialog if not.

        If all required fields have been entered, use the info from the window to create a
        .desktop file in ~/.local/share/applications

        The .desktop file will be named mda_<launcher name>.desktop - the initial
        'mda_' will allow the applet to search for and priorities self created
        .desktop files over system created ones...

        Args:
            widget - the button the caused the event
            event - the event args
        """

        valid_launcher = False
        if self.ccl_win.name == "":
            error_text = "The name of the launcher has not been set"
        elif self.ccl_win.command == "":
            error_text = "The command of the launcher has not been set"
        elif self.ccl_win.icon_filename == "":
            error_text = "The icon of the launcher has not been set"
        else:
            valid_launcher = True

        if valid_launcher == False:
            md = Gtk.MessageDialog(None, Gtk.DialogFlags.MODAL, Gtk.MessageType.ERROR,
                                   Gtk.ButtonsType.OK,
                                   None)
            md.set_markup ('<span size="x-large"><b>Cannot create launcher</b></span>')
            md.format_secondary_text(error_text)
            md.run()
            md.destroy()
            return

        else:
            self.ccl_win.hide()

            # the gnome developer docs at
            # https://developer.gnome.org/integration-guide/stable/desktop-files.html.en
            # state that .desktop filenames should not contain spaces, so....
            dfname = self.ccl_win.name.replace(" ", "-")

            local_apps = os.path.expanduser("~/.local/share/appplications")
            if not os.path.exists(local_apps):
                # ~/.local/share/applications doesn't exist, so create it
                os.mkdir(local_apps)
            dfname = os.path.expanduser("%s/mda-%s.desktop" %(local_apps,dfname))

            dfile = open(dfname, "w")
            dfile.write("[Desktop Entry]\n")
            dfile.write("Name=%s\n" %self.ccl_win.name)
            dfile.write("Type=Application\n")
            dfile.write("Comment=%s\n" %self.ccl_win.comment)
            dfile.write("Exec=%s\n" %self.ccl_win.command)
            dfile.write("Icon=%s\n" %self.ccl_win.icon_filename)
            dfile.write("StartupWMClass=%s\n" %self.ccl_win.wm_class)

            # Code below can be uncommented if adding terminal apps to the dock ever
            # becomes a needed thing
            #term_app = "%s" %self.ccl_win.is_terminal_app
            #dfile.write("Terminal=%s\n" %term_app.lower())

            # we don't want this launcher displayed in the MATe menu
            dfile.write("NoDisplay=true\n")

            dfile.close()

            # create a docked app from the .desktop we just created and add it to the dock
            dock_app = docked_app.DockedApp()
            dock_app.desktop_file = dfname
            dock_app.read_info_from_desktop_file()
            dock_app.is_pinned = True
            dock_app.applet_win = self.applet.window
            dock_app.applet_orient = self.applet.get_orient()
            dock_app.set_indicator(self.indicator)
            dock_app.set_multi_ind(self.multi_ind)

            size = self.applet.get_size()
            self.set_app_icon(dock_app, size)
            self.app_list.append(dock_app)
            self.add_app(dock_app)
            self.show_or_hide_app_icons()
            self.show_or_hide_indicators()
            self.write_settings()

    def show_win(self, win_no):
        """
        Bring the specified window number of the right clicked app to the front

        Args:
            win_no - the window number, starting at 1

        """

        win_list = self.right_clicked_app.get_wnck_windows()
        wnck_win = win_list[win_no-1]
        wnck_win.activate(0)

    def close_win(self, data=None):
        """Close all windows for the right clicked app"""

        win_list = self.right_clicked_app.get_wnck_windows()
        for wnck_win in win_list:
            wnck_win.close(0) # have to send 0 as the event time because we have
                              # no event time to send

    def icon_theme_changed(self, icontheme):
        """ Callback for when the Gtk icon theme changes

        Load the new icon set
        Iterate through each app in self.app_list and get it to reload it's icon
    """

        self.icontheme.rescan_if_needed()

        size = self.applet.get_size()
        for app in self.app_list:
            self.set_app_icon(app, size)

    def copy_wnck_info_to_app(self, app_from_dock, app_from_wnck, wnck_window):
        """Copy info from wnck into a docked applet

        If the wnck app pid is already present in the docked app, just
        copy the windows xids that are not in the docked app

        If the wnck app pid is not present, copy all of the the app_info
        """

        if app_from_dock.wnck_class is None:
            app_from_dock.wnck_class = app_from_wnck.wnck_class
        app_from_dock.set_app_name(app_from_wnck.app_name)
        if app_from_dock.wm_class_name == "":
            app_from_dock.wm_class_name = app_from_wnck.wm_class_name

        for wai in app_from_wnck.app_info:
            # look for a process in the docked app with an identical pid

            existing_pid = False
            for dai in app_from_dock.app_info:

                # different wnck_apps for a single app can share the same pid
                # so just check the wnck_apps for equivalency
                if dai.app == wai.app:
                    existing_pid = True

                if existing_pid == True:
                    # we need to merge info from the new details into the dock_app

                    for xid in wai.windows:
                        try:
                            unused_var = dai.windows.index(xid)
                            #if we get here, the window was found, so there's no
                            #need to do anything else

                        except ValueError:
                            # if we get here, the window wasn't found so it needs to be added
                            dai.windows.append(xid)

                    break

            if existing_pid == False:
                # add the info for the new process
                app_from_dock.app_info.append(wai)

    def find_desktop_file (self, df_name):
        """ Find the full filename of a specified .desktop file

        Search the following directories (and their subdirectories) for
        the specified filename
            /usr/share/applications
            /usr/local/share/applications
            ~/.local/share/applications

        Args :
            df_name : the name of the .desktop file e.g. pluma.desktop. The
                      .desktop extension must be included

        Returns:
            The full filename (path + filename) of the desktop file if it exists
            or "" otherwise
        """

        srch_dirs = ["/usr/share/applications/", \
                     "/usr/local/share/applications/", \
                     os.path.expanduser("~/.local/share/applications/")]

        for srch_dir in srch_dirs:
            for the_dir, dir_list, file_list in os.walk(srch_dir):
                try:
                    unused_var = file_list.index(df_name)

                    #if we get here the file is found
                    the_name = os.path.join(the_dir, df_name)
                    return the_name

                except ValueError:
                    pass

        return ""

    def setup_app_list(self):
        """Setup the list of docked apps.

        First, read the list of pinned apps from the settings and add them to the app list

        Then iterate through the running apps, and then either:
            if this is a non-pinned app add it to app list
            if this is a pinned app, integrate the running app info with the pinned app details
            already set up

        Also, set up event handlers allowing us keep track of window open and close events
        and active window change events
        """

        self.app_list = []

        pinned_apps = self.settings.get_value("pinned-apps").unpack()

        # the settings contain a list of .desktop files, so we need to find and read each
        # file
        for pinned_app in pinned_apps:
            dock_app = docked_app.DockedApp()

            full_name = self.find_desktop_file(pinned_app)
            if full_name != "":
                dock_app.desktop_file = full_name
                if dock_app.read_info_from_desktop_file():
                    self.app_list.append(dock_app)

            dock_app.is_pinned = True

        self.wnck_screen.force_update()  # recommended per Wnck documentation

        for wnck_window in self.wnck_screen.get_windows():

            win_type = wnck_window.get_window_type()

            if ((win_type == Wnck.WindowType.NORMAL) or (win_type == Wnck.WindowType.DIALOG)) and \
                    wnck_window.is_skip_tasklist() == False:

                wnck_class = wnck_window.get_class_group()

                wnck_app = wnck_window.get_application()

                # setup a new docked app object with info from wnck
                dock_app = docked_app.DockedApp()
                dock_app.applet_win = self.applet.window
                dock_app.setup_from_wnck(wnck_app, wnck_class, self.app_match)

                # if this is a pinned app, merge the running app details with the item already
                # set up in app_list
                for app in self.app_list:
                    if app.desktop_file == dock_app.desktop_file:
                        # copy the running app's info to the pinned dock item
                        self.copy_wnck_info_to_app(app, dock_app, wnck_window)

                        break
                else:
                    # it's not a pinned app so add it to the app list
                    self.app_list.append(dock_app)

        self.wnck_screen.connect("active-window-changed", self.active_win_changed)
        self.wnck_screen.connect("active-workspace-changed", self.active_workspace_changed)
        self.wnck_screen.connect("window-opened", self.window_opened)
        self.wnck_screen.connect("window_closed", self.window_closed)

    def active_workspace_changed(self, wnck_screen, previously_active_space):
        """ Event handler for the active workspace change even

        Show or hide pinned and unpinned dock apps as appropriate

        Arguments :
            wnck_screen : the screen that emitted the event. Will be the same as
                          self.wnck_screen
            previously_active_space : the workspace that was previously active

        """

        self.show_or_hide_app_icons()
        self.show_or_hide_indicators()

    def active_win_changed(self, wnck_screen, prev_active_window):
        """Event handler for the window change event

        Remove the highlighted background from any prevously active app and redraw its icon

        Set the new app as active and redraw it with a highlighted background

        Args:
            wnck_screen :  the screen on which the event occurred - will be the same as
                        :  self.wnck_screen
            prev_active_window : the wnck_window that was previously active

        """

        for app in self.app_list:
            if app.is_active == True:
                app.is_active = False
                app.queue_draw()

        new_win = self.wnck_screen.get_active_window()

        if new_win is not None:
            # the desktop itself can be the new active window. we need to ignore it if so....
            # (fix for https://bugs.launchpad.net/ubuntu/+source/mate-dock-applet/+bug/1550392
            if new_win.get_name().lower()!="x-caja-desktop":
                new_cg = new_win.get_class_group()
                new_wm_class_name = new_cg.get_res_class()
                new_app = new_win.get_application()
                for app in self.app_list:
                     if app.wm_class_name == new_wm_class_name:
                         for aai in app.app_info:
                            if new_app == aai.app:
                                app.is_active = True
                                app.last_active_win = new_win
                                app.queue_draw()
                                break

    def window_opened(self, wnck_screen, wnck_window):
        """Event handler for the window_opened event

        If an aready running app has opened a new window, the window
        is added to to the running apps info

        If a newly lauched app is opening a new window, setup the app on the
        dock

        Args:
            wnck_screen : the screen on which the event occurred
            wnck_window : the newly opened window

        """

        # we're only interested when normal and dialog windows
        if (wnck_window.get_window_type() != Wnck.WindowType.NORMAL) and \
           (wnck_window.get_window_type() != Wnck.WindowType.DIALOG):
            return
        wnck_app = wnck_window.get_application()

        if not wnck_window.is_skip_tasklist():

            # setup a new DockedApp
            wnck_class = wnck_window.get_class_group()
            dock_app = docked_app.DockedApp()
            dock_app.applet_win = self.applet.window
            dock_app.applet_orient = self.applet.get_orient()
            dock_app.set_indicator(self.indicator)
            dock_app.set_multi_ind(self.multi_ind)
            got_desktop = dock_app.setup_from_wnck(wnck_app, wnck_class, self.app_match)

            # look for the app relating to the window in the dock
            in_dock = False
            for app in self.app_list:
                if got_desktop == True:
                    if app.desktop_file == dock_app.desktop_file:
                        in_dock = True
                # if we don't have the .desktop file then things get a little more
                # complicated
                elif app.has_wnck_app(wnck_app) or \
                     ((app.wnck_class == dock_app.wnck_class or \
                     app.wm_class_name.upper() == dock_app.wm_class_name.upper() and \
                     # test below is fix for https://bugs.launchpad.net/ubuntu-mate/+bug/1555324
                     app.wm_class_name.strip() != "")):   #
                         in_dock = True

                if in_dock == True:
                    # found it, so copy the running app's info to the pinned dock item
                    self.copy_wnck_info_to_app(app, dock_app, wnck_window)

                    # set the minimize target for the new window
                    app.set_icon_geometry()

                    # if the mouse pointer is over the app's dock icon, regenerate the list
                    # of right click menu items to take acount of the new window
                    if app.has_mouse:
                        self.set_actions_for_app(app)

                    # start the dock icon pulsing to let the user know something has happened
                    if not app.is_pulsing:
                        app.start_pulsing()
                    break

            if in_dock == False:
                # append the app to the dock

                size = self.applet.get_size()
                self.set_app_icon(dock_app, size)
                self.app_list.append(dock_app)
                self.add_app(dock_app)
                self.show_or_hide_app_icons()
                self.show_or_hide_indicators()

    def window_closed(self, wnck_screen, wnck_window):
        """Event handler for the window_closed event

        Find the app relating to the closed window.

        If it has no more open windows mark it as not running and
        redraw its icon without the running indicator.

        If the are open windows remaining, remove the closed window from
        the apps list of windows

        Args:
            wnck_screen : the screen on which the event occurred
            wnck_window : the closed window

        """


        # we're only interested in the closure of normal and dialog windows
        if (wnck_window.get_window_type() != Wnck.WindowType.NORMAL) and \
           (wnck_window.get_window_type() != Wnck.WindowType.DIALOG):
            return

        wnck_app = wnck_window.get_application()
        if wnck_app is None:

            # this always seems to be the case - so we need to find the app another
            # way - look through each of the running apps for the one which
            # has the closed window in it's window list

            # this is done by using xids - using wnck_windows in the app_info tuple
            # didn't seem to work very well

            xid = wnck_window.get_xid()
            for app in self.app_list:
                for aai in app.app_info:
                    try:
                        # a valueerror exception occurs if the window is not found
                        unused_var = aai.windows.index(xid)

                        # we've found the app so remove the window from it's list
                        aai.windows.remove(xid)

                        do_redraw = False

                        # if the app has no more open windows, mark it as closed
                        if len(aai.windows) == 0:
                            # there no more open windows for this process. Does the app
                            # have any other running processes ?
                            if len(app.app_info) == 1:
                                # No, it doesn't ////

                                app.app_info = []
                                if not app.is_pinned:

                                    #rmeove the app from the dock
                                    self.remove_app_from_dock(app)
                                else:
                                    app.is_active = False
                                    do_redraw = True
                            else:
                                # remove this processes info from docked app
                                app.app_info.remove(aai)
                                do_redraw = True
                        else:
                            do_redraw = True

                        # was the closed window was the last active window for the app ?
                        if app.last_active_win == wnck_window:
                            app.last_active_win = None

                        if do_redraw:
                            app.queue_draw()

                        if app.has_mouse:
                            self.set_actions_for_app(app)
                        break

                    except ValueError:
                        pass

    def show_or_hide_app_icons(self):
        """ If we're only showing unpinned apps from the current workspace then
            then show/hide as appropriate.

            Finally, recalculate all app minimization targets
        """

        if self.show_all_apps:
            for app in self.app_list:
                if not app.is_visible():
                    app.show_icon()
        else:
            cur_ws = self.wnck_screen.get_active_workspace()
            for app in self.app_list:
                if not app.is_pinned:
                    if app.has_windows_on_workspace(cur_ws):
                        app.show_icon()
                    else:
                        app.hide_icon()

        # recalculate all apps icon geometry
        for app in self.app_list:
            app.set_icon_geometry()

    def show_or_hide_indicators(self):
        """ Show or hide app indicators as appropriate

        If we're only showing indicators for apps which have windows on the current workspace
        then set the apps hide_indicators setting as appropriate. Otherwise, set the
        hide_indicators setting to False.
        """

        cur_ws = self.wnck_screen.get_active_workspace()
        for app in self.app_list:
            if self.win_from_cur_ws_only:
                app.ind_ws = cur_ws
            else:
                app.ind_ws = None

    def remove_app_from_dock(self, app):
        """Remove an app from the dock.

        Remove the app from the app_list

        Remove the app's drawing area from self.box

        Args:
            app : the app to be removed

        """

        self.app_list.remove(app)
        self.box.remove(app.drawing_area)

        app = None

    def set_app_icon(self, dock_app, size):
        """ Sets up an app's icon, scaling it to a specified size

        Select an appropriate icon size based on the specified size

        Load the app's icon, using a fallback STOCK_EXEC as a fallback

        Scale the icon to the specified size

        Args:
            dock_app : the DockedApp
            size : the required icon size in pixels
        """

        if size >= 56:
            icon_size = 64
            stock_size = Gtk.IconSize.DIALOG
        elif size >= 40:
            icon_size = 48
            stock_size = Gtk.IconSize.DIALOG
        elif size >= 28:
            icon_size = 32
            stock_size = Gtk.IconSize.DND
        elif size >= 20:
            icon_size = 24
            stock_size = Gtk.IconSize.LARGE_TOOLBAR
        else:
            icon_size = 16
            stock_size = Gtk.IconSize.BUTTON

        if self.icontheme.has_icon(dock_app.icon_name):

            icon_info = self.icontheme.choose_icon([dock_app.icon_name, None], icon_size, 0)
            dock_app.icon_filename = icon_info.get_filename()

            try:
                pixbuf = icon_info.load_icon()
            except GLib.GError:
                # default to a stock icon if we couldn't load the app icon
                pixbuf = self.applet.render_icon(Gtk.STOCK_EXECUTE, stock_size, None)
                dock_app.icon_filename = "STOCK_EXECUTE"

        else:
            # the default theme has no icon for the app, so there are a few things we
            # can do...
            #
            # 1 .. quick and dirty - check to see if the icon points to an actual file
            #                        or ...
            #                        look in /usr/share/icons/hicolor/<icon_size>x<iconsize>/
            #                        apps/ and
            #                        ~/.local/share/icons/icons/hicolor</icon_size>x<icon_size>/apps/
            #                        for the icon name or ...
            #                        look in /usr/share/pixmaps for an icon of any type with
            #                        the same name as the app
            #                        then ...
            #                        look in ~/.local/share/icons for an icon with the same name
            #                        and extension as the icon
            #
            # 2 .. sloooow         - iterate through each installed icon theme and try to
            #                        find the app - not implement for now

            # the png method. look for lower and uppercased variations of the filename
            # and note that all files in /usr/share/pixmaps are .png

            icon_file = ""
            if os.path.isfile(dock_app.icon_name):
                pixbuf = GdkPixbuf.Pixbuf.new_from_file(dock_app.icon_name)
            else:
                icon_name = dock_app.icon_name

                #look in the 'hicolor' icon directories for the icon file
                icon_path = "/usr/share/icons/hicolor/%dx%d/apps/" %(icon_size, icon_size)
                if os.path.isfile("%s%s" %(icon_path, icon_name)):
                    icon_file = "%s%s" %(icon_path, icon_name)
                else:
                    icon_path = os.path.expanduser("~/.local/share/icons/hicolor/%dx%d/apps/" %(icon_size, icon_size))
                    if os.path.isfile("%s%s" %(icon_path, icon_name)):
                        icon_file = "%s%s" %(icon_path, icon_name)

                # if we still haven't found the icon, look in /usr/share/pixmaps for a .png file
                if icon_file == "":
                    icon_name = os.path.splitext(dock_app.icon_name)[0] # remove any extension
                    if os.path.isfile("/usr/share/pixmaps/%s.png" %icon_name):
                        icon_file = "/usr/share/pixmaps/%s.png" %icon_name
                    elif os.path.isfile("/usr/share/pixmaps/%s.png" %icon_name.upper()):
                        icon_file = "/usr/share/pixmaps/%s.png" %icon_name.upper()
                    elif os.path.isfile("/usr/share/pixmaps/%s.png" %icon_name.lower()):
                        icon_file = "/usr/share/pixmaps/%s.png" %icon_name.lower()

                # final attempt - look in ~/.local/share/icons for the icon
                if icon_file == "":
                    if os.path.isfile(os.path.expanduser("~/.local/share/icons/%s" %dock_app.icon_name)):
                        icon_file = os.path.expanduser("~/.local/share/icons/%s" %dock_app.icon_name)

                # if we've found an icon, load it
                if icon_file != "":
                        pixbuf = GdkPixbuf.Pixbuf.new_from_file(icon_file)
                else:
                    # if not, use a stock icon to represent the app
                    pixbuf = self.applet.render_icon(Gtk.STOCK_EXECUTE, stock_size, None)
                    dock_app.icon_filename = "STOCK_EXECUTE"

        # scale the icon to the size that is available
        # Note - we're allowing for a 3 pixel border all around the icon, hence using size-6
        pixbuf = pixbuf.scale_simple(size -6, size - 6, \
                              GdkPixbuf.InterpType.BILINEAR)

        dock_app.set_drawing_area_size(size)
        dock_app.set_pixbuf(pixbuf)

    def add_app(self, dock_app):
        """
        Add an app's drawing area to the VBox/Hbox container

        Args:
            dock_app : the DockedApp
        """

        self.box.add(dock_app.drawing_area)


    def create_box(self, orientation):
        """Create a vertical or horizontal (depending on the applet orientation)
           box to contain the docked apps areas.

        Args:
            orientation : the applet orientation
        """

        if orientation == MatePanelApplet.AppletOrient.LEFT or \
           orientation == MatePanelApplet.AppletOrient.RIGHT:
            self.box = Gtk.VBox()
        else:
            self.box = Gtk.HBox()

        self.box.set_spacing(1)

    def setup_dock(self):
        """Setup the dock."

        Add all pinned apps to the dock

        Add all non-pinned running apps to the dock

        Setup all apps according to the applet size and orientation

        """


        # make sure the applet is correctly oriented
        orientation = self.applet.get_orient()
        self.create_box(orientation)

        # setup up pinned and non-pinned running apps
        self.setup_app_list()
        applet_size = self.applet.get_size()

        # add the apps to the dock
        for dock_app in self.app_list:
            dock_app.applet_orient = orientation
            dock_app.applet_win = self.applet.window
            self.set_app_icon(dock_app, applet_size)
            dock_app.set_indicator(self.indicator)
            dock_app.set_multi_ind(self.multi_ind)
            self.add_app(dock_app)

        self.show_or_hide_app_icons()
        self.show_or_hide_indicators()

    def set_new_orientation(self, new_orient):
        """Change the dock applet to a new applet orientation

        Remove all app's drawing areas from the V/HBox

        Remove the V/HBox and create a new one according to the new orientation

        Add all of the app's drawing areas to the new V/HBox

        Set all of the apps to use the new orientations and recalculate all
        of their minimize targets

        Args:
            new_orient : the new applet orientation
        """

        for dock_app in self.app_list:
            self.box.remove(dock_app.drawing_area)

        self.applet.remove(self.box)
        self.box = None

        self.create_box(new_orient)

        for dock_app in self.app_list:
            self.box.add(dock_app.drawing_area)
            dock_app.set_icon_geometry()   # reset minimize target
            dock_app.applet_orient = new_orient


        self.applet.add(self.box)

    def set_app_minimise_targets(self):
        """ Set all docked apps to recalculate their minimise targets"""

        for app in self.app_list:
            app.set_icon_geometry()

    def get_app_at_mouse(self, mouse_x, mouse_y):
        """
        Find the app underneath the mouse cursor.

        Args:
            mouse_x : the x coord of the mouse
            mouse_y : the y coord of the mouse

        Returns:
            The app under the mouse, or None if one could not be found
        """

        for app in self.app_list:
            if app.is_visible():
                alloc = app.drawing_area.get_allocation()
                if (mouse_x >= alloc.x) and (mouse_x <= alloc.x + alloc.width):
                    if (mouse_y >= alloc.y) and (mouse_y <= alloc.y + alloc.height):
                        return app

        return None

    def reset_win_list_timer(self):
        """ Reset win_list timer

        If the timer is already instantiated, delete it.

        Start a new timer with the appropriate delay

        """

        if self.win_list_timer is not None:
            GObject.source_remove(self.win_list_timer)

        self.win_list_timer = GObject.timeout_add(self.win_list_delay, self.show_win_list)

    def stop_win_list_timer(self):
        """ Stop the win list timer
        """

        if self.win_list_timer is not None:
            GObject.source_remove(self.win_list_timer)
            self.win_list_timer = None

    def show_win_list(self):
        """ Show the the list of open windows for the currently highlighted app

        Get the currently highlighted app. If the highlighted app is not running
        or a window list is already being displayed for it, or a user interaction
        has already dismissed the window list, then do nothing

        Otherwise, fill the window list, set the window position and set the
        screen areas where the mouse must remain or the window list will hide
        """

        panel_space = 5 # how many pixels away from the panel the window list will
                        # appear

        win_border = 15 # size of the border (in pixels) around the window list where
                        # the mouse must remain, outside of which the window list wil;
                        # hide

        highlighted_app = self.app_with_mouse
        if (highlighted_app is None) or (highlighted_app.is_running == False):
            return

        if highlighted_app is not None:

            # we need to show to window list

            # first reset, the window list
            self.app_win_list.dismissed = True
            self.app_win_list.hide()
            self.app_win_list.clear_win_list()

            self.app_win_list.the_app = highlighted_app
            self.app_win_list.setup_list(self.win_from_cur_ws_only)
            self.app_win_list.clear_mouse_areas()

            # add the applet to the mouse areas
            applet_x, applet_y = self.applet.window.get_root_coords(0,0)
            applet_w, applet_h = self.applet.window.get_size()

            if applet_x < 0:
                applet_x = 0
            if applet_y < 0:
                applet_y = 0

            self.app_win_list.add_mouse_area (Gdk.Rectangle(applet_x, applet_y, applet_w, applet_h))

            # get the display resolution
            screen = self.app_win_list.get_screen()
            screen_w = screen.get_width()
            screen_h = screen.get_height()

            # work out where to place the window - adjacent to the panel and centered on the
            # highlighted dock app

            app_alloc = highlighted_app.drawing_area.get_allocation()
            aax, aay = self.applet.window.get_root_coords(app_alloc.x, app_alloc.y)
            self.app_win_list.realize()
            win_w, win_h = self.app_win_list.get_size()

            orientation = self.applet.get_orient()
            if orientation == MatePanelApplet.AppletOrient.RIGHT:
                centre_pos  = aay + app_alloc.height/2
                win_x = applet_w + panel_space
                win_y = centre_pos - (win_h/2)

                # adjust win_y in case we're off the top the screen...
                if win_y < panel_space:
                    win_y = panel_space

                # adjust win_y if case the window list extends beyound the end of the panel ..
                if (win_y + win_h) > screen_h:
                    win_y = screen_h - win_h - panel_space

                # setup a new mouse area covering the window (minus a border) and extending
                # to the panel
                self.app_win_list.add_mouse_area(Gdk.Rectangle(applet_x,
                                                               win_y - win_border ,
                                                               win_x +win_w + win_border,
                                                               win_h + (2*win_border)))

            elif orientation == MatePanelApplet.AppletOrient.LEFT:
                centre_pos  = aay + app_alloc.height/2
                win_x = applet_x - panel_space - win_w
                win_y = centre_pos - (win_h/2)

                # adjust win_y in case we're off the top the screen...
                if win_y < panel_space:
                    win_y = panel_space

                # adjust win_y if case the window list extends beyound the end of the panel ..
                if (win_y + win_h) > screen_h:
                    win_y = screen_h - win_h - panel_space

                # setup a new mouse area covering the window (minus a border) and extending
                # to the panel
                self.app_win_list.add_mouse_area(Gdk.Rectangle(win_x - win_border,
                                                               win_y - win_border,
                                                               applet_x + applet_w,
                                                               win_h + (2*win_border)))

            elif orientation == MatePanelApplet.AppletOrient.DOWN:
                centre_pos  = aax+ app_alloc.width/2
                win_x = centre_pos - (win_w / 2)
                win_y = applet_h +  panel_space

                # adjust win_x in case we're off the left of the screen...
                if win_x < panel_space:
                    win_x = panel_space

                # adjust win_x if case the window list extends beyond the end of the panel ..
                if (win_x + win_w) > screen_w:
                    win_x = screen_w - win_w - panel_space

                # setup a new mouse area covering the window (minus a border) and extending
                # to the panel
                self.app_win_list.add_mouse_area(Gdk.Rectangle(win_x - win_border,
                                                               applet_y,
                                                               win_w + (2*win_border),
                                                               win_y + win_h + win_border))
            else:
                centre_pos  = aax+ app_alloc.width/2
                win_x = centre_pos - (win_w / 2)
                win_y = applet_y - panel_space - win_h

                # adjust win_x in case we're off the left of the screen...
                if win_x < panel_space:
                    win_x = panel_space

                # adjust win_x if case the window list extends beyond the end of the panel ..
                if (win_x + win_w) > screen_w:
                    win_x = screen_w - win_w - panel_space

                # setup a new mouse area covering the window (minus a border) and extending
                # to the panel
                self.app_win_list.add_mouse_area(Gdk.Rectangle(win_x - win_border,
                                                               win_y - win_border,
                                                               win_w + (2*win_border),
                                                               applet_y  + applet_h))
            self.app_win_list.move (win_x, win_y)
            self.app_win_list.show_all()

            self.win_list_timer = None
            return False

    def hide_win_list(self):
        """ Hide the window list """

        if self.app_win_list is not None:
            self.app_win_list.hide()

    def minimize_or_restore_windows(self, app, event):
        """ Minimize or restore an app's windows in response to a left click of
            it's dock icon

        the action to perform (minimizing, moving workspace, activating)
        is decided as follows:
           if (the app's windows are all minimized) or
               (the app s one or more unminimized window but is not the active app)
           then
               restore the app's last active window or all windows (based on the
               user's settings). If the active window is on a  different workspace
               then activate that workspace
           else:
               the app is currently the active app so all of the app
               windows will be minimized

        but first, hide any app window list that is being shown and stop the
        window list timer

        Note: As of MATE 1.12 wnck_window.activate does not seem to work properly
              if we specify our own event time. However, if an event time of
              0 (i.e. now) is specfied all works as expected. However, when the
              applet is run from the command line, lots of these messages
              'Wnck-WARNING **: Received a timestamp of 0; window activation
               may not function properly' appear, so another solution may need
              to be found in the future

        Args:
            app: the docked app whose windows are to be minimized or restored
            event : the mouse click event

        """

        self.stop_win_list_timer()
        self.hide_win_list()

        win_list = app.get_wnck_windows()

        restore_win = (not app.has_unminimized_windows()) or \
                          (app.has_unminimized_windows() and (app.is_active==False))
        if restore_win:
            last_active_win = app.last_active_win

            # the last active window may be set to None (e.g. if the app's active window has been closed
            # and no other window has been made active afterwards). Therefore, if there is no active last window
            # activate the app's first normal window
            # (fix for https://bugs.launchpad.net/ubuntu/+source/mate-dock-applet/+bug/1550392)
            if last_active_win is None:
                for window in win_list:
                    win_type = window.get_window_type()
                    if ((win_type == Wnck.WindowType.NORMAL) or \
                            (win_type == Wnck.WindowType.DIALOG)) and \
                            (not window.is_skip_tasklist()):
                        last_active_win = window
                        break

            # if we're restoring all windows, do this now before we finally activate the last active window
            if self.click_restore_last_active == False:
                for window in win_list:
                    win_type = window.get_window_type()
                    if ((win_type == Wnck.WindowType.NORMAL) or \
                            (win_type == Wnck.WindowType.DIALOG)) and \
                            (not window.is_skip_tasklist()) and \
                            (window != last_active_win):
                        window.activate(0)
                        sleep(0.01)   # allow the window manager time to activate
                                      # the window

                app.last_active_win = last_active_win

            wnck_screen = last_active_win.get_screen()
            wnck_aws = self.wnck_screen.get_active_workspace()
            wnck_ws = last_active_win.get_workspace()

            # the window's active workspace can be null if it is visible on all workspaces
            # or if it is not on any workspace (I'm looking at you caja-desktop!!!!!)
            # (fix for https://bugs.launchpad.net/ubuntu/+source/mate-dock-applet/+bug/1550392 and
            # https://bugs.launchpad.net/ubuntu-mate/+bug/1555336 (regarding software updater))
            if wnck_aws is not None and wnck_ws is not None and (wnck_aws != wnck_ws):
                wnck_ws.activate(0)
                sleep(0.01)

            # rarely, the last active win does not end up as the active window if we
            # activate here, so instead a workaround which seems to do the trick
            # is use a timer as below
            GObject.timeout_add(20, win_activation_timer, [last_active_win, event.time])

        else:
            #minimize all windows and do the last active window last of all

            last_active_win = app.last_active_win

            for window in win_list:
                win_type = window.get_window_type()
                if ((win_type == Wnck.WindowType.NORMAL) or \
                     (win_type == Wnck.WindowType.DIALOG)) and \
                     (not window.is_skip_tasklist()) and \
                     (window != last_active_win):
                         window.minimize()
                         sleep(0.01)

            app.last_active_win = last_active_win
            if last_active_win is not None:
                last_active_win.minimize()
                sleep(0.01)


    def do_window_scroll(self, scroll_dir, event_time):
        """ Scroll to the next/previous window of the currently active app

        This function is called in response to the mouse scroll event on the
        panel applet

        Depending on the scroll direction, make the next or previous window of
        the current app active. Scrolling will wrap around in both directions

        If the app only has one window or we don't know which window was last active
        (e.g. because the applet has only just started) then make the first window
        active

        If the new window is not on the current workspace, change to the relevant
        workspace

        Also, hide the app window list and stop any timer that might be running

        Args:
            scroll_dir : A GDK.ScrollDirection which indicates whether to go
                         forwards or backwards through the window list
            event_time : the time scroll event occurred
        """

        # we're only interested in scroll up and down events....
        if (scroll_dir != Gdk.ScrollDirection.UP) and \
           (scroll_dir != Gdk.ScrollDirection.DOWN):
            return

        if self.app_with_mouse is not None:
            app = self.app_with_mouse
        else:
            return

        # if the app isn't running, there's nothing to do...
        if app.is_running() == False:
            return

        windows = app.get_wnck_windows()
        if (app.last_active_win is None) or (len(windows) == 1):
            new_index = 0
        else:
            # work out which window we want to activate
            try:
                index = windows.index (app.last_active_win)
            except ValueError:
                index = 0  # in case of error activate the first window

            if scroll_dir== Gdk.ScrollDirection.UP:
                if index == 0:
                    new_index = len(windows)-1
                else:
                    new_index = index - 1
            else:
                if index == len(windows)-1:
                    new_index = 0
                else:
                    new_index = index +1

        # hide the window list and stop any timer
        self.hide_win_list()
        self.stop_win_list_timer()

        # if the new window is on a different workspace, we need to switch workspace
#            wnck_screen = app.last_active_win.get_screen()
        wnck_aws = self.wnck_screen.get_active_workspace()
        wnck_ws = windows[new_index].get_workspace()

        if wnck_aws is not None and (wnck_aws != wnck_ws):
            wnck_ws.activate(0)
            sleep(0.01)

        #activate the new window
        windows[new_index].activate(0)

def win_activation_timer(args):
    """ Timer function to be called by GObject.timeout_add and which
        will activate a specified wnck window

    Args:
        args - a tuple containing these items
               args[0] - the wnck window to activate
               args[1] - the event time at which the timer was activated

    Returns:
        False - to cancel the timer
    """

    # as of MATE 1.12 it seems we need to use an event time of 0 (i.e. now) to the window to
    # activate properly
    args[0].activate(0)
    sleep(0.01)
    return (False)

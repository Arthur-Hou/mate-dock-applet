#!/usr/bin/env python3

"""Provide functionality relating to an application dock

Manage a list of pinned and non-pinned dock apps.

Handle all mouse ui events for docked apps
Respond to window opening and closing events from libwnck
Respond to changes to the Gtk icon theme and update all docked apps
Load and save dock settings (pinned apps and indicator type)

respond to selections made in the applet right click menu, specifically
    : allow apps to be pinned to the dock
    : allow apps to unpinned from the dock
    : allow app icons be to moved to a different position on the dock
    : disply an About dialog
    : display a Preferences dialog
"""

# Copyright (C) 1997-2003 Free Software Foundation, Inc.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; either version 2 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301, USA.
#
# Author:
#     Robin Thompson

import gi
gi.require_version("Gtk", "2.0")
gi.require_version("MatePanelApplet", "4.0")
from gi.repository import Gtk
from gi.repository import Gdk
from gi.repository import MatePanelApplet
from gi.repository import GObject

gi.require_version("Wnck", "1.0")
from gi.repository import Wnck

from gi.repository import GdkPixbuf
from gi.repository import Gio
from gi.repository import GLib
import os
import os.path
from time import sleep

import docked_app
import dock_prefs
import dock_about
import dock_custom_launcher
import dock_win_list
import dock_xml

from log_it import log_it as log_it

class Dock(object):
    """The main application dock class

        Attributes:
            applet : the MATE panel applet
            wnck_screen : the currently active wnck_screen. Assumed to be the default
                          wnck_screen on applet start up
            window : 
            app_list : the list of DockedApp objects. Will contain running/non-running
                       pinned apps and running unpinned apps
            box    : A Gtk HBox or VBox (depending on the applet orientation) containing
                     the drawing areas of each of the app in app_list
            icontheme : used to load application icons and detect changes in the icon theme
            about_win : the about window
            prefs_win : the preferences window
            ccl_win   : the create custom launcher window
            app_with_mouse : the DockedApp that the mouse is currently over
            active_app : the DockedApp that is currently the foreground app
            right_clicked_app: the app that was most recently right clicked
            settings_path : the GIO.Settings path for the applet
            settings : GIO.Settings - the settings for the applet
            indicator : the indicator type (light or dark)
            dock_action_group : Gtk Action group containing all of the actions
                                for the applet right click menu
            app_win_list : a replacement for the default tooltip - a window which lists
                           the currently highlighted  app's open windows and allows the 
                           user to select one
            win_list_delay : the amount of time (in milliseconds) after which the app's
                             window list will pop up when the mouse hovers over the app
            win_list_timer : timer object used to cound win_list_delay

    """

    def __init__(self, applet):
        """Init the Dock.

        Load settings
        Setup the applet right click menu and actions
        Set default values
        """

        super().__init__()

        self.applet = applet    # the panel applet, in case we need it later

        self.app_list = []
        self.box = None
        self.icontheme = Gtk.IconTheme.get_default()
        self.icontheme.connect("changed", self.icon_theme_changed)

        self.window = None

        self.wnck_screen = Wnck.Screen.get_default()

        self.app_with_mouse = None      # the dock app that mouse is currently over
        self.active_app = None          # the currently active app
        self.right_clicked_app = None     # the app that most recently had a right click

        self.settings_path = self.applet.get_preferences_path()
        self.settings = Gio.Settings.new_with_path("org.mate.panel.applet.dock", \
                                                    self.settings_path)

        # specify the xml file to be used as an alternative storage location for the
        # applet settings
        self.xml_conf=os.path.expanduser("~/.config/mate_dock_applet.conf")

        self.prefs_win = None
        self.about_win = None
        self.ccl_win = None
        self.indicator = 0 
        self.multi_ind = False
        self.show_all_apps = True
        self.click_restore_last_active = True
        self.read_settings()

        self.dock_action_group = None
        
        self.app_win_list  = dock_win_list.DockWinList()
        self.app_win_list.icontheme = self.icontheme
        self.win_list_delay = 500
        self.win_list_timer = None

        self.setup_menu()

    def read_settings(self):
        """ Read the current dock settings from dconf

            If this particular dock has not been run before and a settings xml file exists
            offer to import the settings from the xml file ...

        """


        if (self.settings.get_boolean("first-run") == True) and \
                (os.path.isfile(self.xml_conf)):

            # this dock is being run for the first time, so if we have any saved settings
            # from other docks, offer to import them ..
            md = Gtk.MessageDialog(None, Gtk.DialogFlags.MODAL, Gtk.MessageType.QUESTION, 
                                   Gtk.ButtonsType.YES_NO,
                                   None)
            md.set_markup ('<span size="x-large"><b>Import settings?</b></span>')
            md.format_secondary_text("Settings from a previous dock have been found. Do you want to " \
                                     "import the other dock's pinned apps and settings?")
            response = md.run()
            if response == Gtk.ResponseType.YES:

                xml_settings = dock_xml.read_xml(self.xml_conf)

                if xml_settings[0] == True:
                    # the settings were read correctly, so set everything up
                
                    pinned_apps = []
                    for pinned_app in xml_settings[1]:
                        pinned_apps.append(pinned_app)

                    self.indicator = xml_settings[2]
                    self.show_all_apps = xml_settings[3]
                    self.multi_ind = xml_settings[4]
                    self.click_restore_last_active = xml_settings[5]

                    # now, immediately write the settings to dconf and back to the config file 
                    # so the dock can access them
                    
                    self.settings.set_value("pinned-apps", GLib.Variant('as', pinned_apps))
                    self.settings.set_int("indicator-type", self.indicator)
                    self.settings.set_boolean("multi-ind", self.multi_ind)
                    self.settings.set_boolean("apps-from-all-workspaces", self.show_all_apps)
                    self.settings.set_boolean("first-run", False)
                    self.settings.set_boolean("click-restore-last-active", self.click_restore_last_active)
                    dock_xml.write_xml(self.xml_conf, pinned_apps, self.indicator, \
                           self.show_all_apps, self.multi_ind, self.click_restore_last_active)

                    md.destroy()
                    return
                else:

                    # the xml was not read
                    # this could be due to an error or because new versions of the applets have added
                    # configuration options not yet in the user's xml file. To recover, simply close
                    # the dialog and assume a default set of options
                    md.destroy()


        self.indicator = self.settings.get_int("indicator-type")
        self.multi_ind = self.settings.get_boolean("multi-ind")
        self.show_all_apps = self.settings.get_boolean("apps-from-all-workspaces")
        self.click_restore_last_active = self.settings.get_boolean("click-restore-last-active")

    def write_settings(self):
        """Write the current dock settings.

        Write a list of all of the currently pinned apps .desktop files
        Write the indicator type, whether to use multiple indicators,
        and whether to show unpinned apps from all workspaces

        Set the first-run indicator to False
        """

        pinned_apps = []
        for dock_app in self.app_list:

            if (dock_app.desktop_file is not None) and (dock_app.is_pinned):
                pinned_apps.append(os.path.basename(dock_app.desktop_file))

        if self.settings:
            self.settings.set_value("pinned-apps", GLib.Variant('as', pinned_apps))
            self.settings.set_int("indicator-type", self.indicator)
            self.settings.set_boolean("multi-ind", self.multi_ind)
            self.settings.set_boolean("apps-from-all-workspaces", self.show_all_apps)
            self.settings.set_boolean("click-restore-last-active", self.click_restore_last_active)
            self.settings.set_boolean("first-run", False)

        dock_xml.write_xml(self.xml_conf, pinned_apps, self.indicator, \
                           self.show_all_apps, self.multi_ind, self.click_restore_last_active)

    def set_actions_for_app(self, app):
        """Show or hide actions in the context menu so that only relevant ones are
           shown for the specified app

           If the app is pinned, do not show the pin action.

           If the app in not pinned, don't show the unpin action.

           Depending on applet orientation actions to move the app left/right
           or up/down along the dock need to shown or hidden.

           If the app is the first or last on the dock, then the options to
           move it up/left or down/right will also need to be hidden

           Include the app name in the menu text e.g. Pin Caja to the dock

           If the app has more than one window on screen, show actions allowing
           the user to select one

           If the app is running and has one or more windows on screen, show
           an option allowing them to be closed

           If the app does not have a desktop file, show an option allowing a 
           custom launcher to be created

           Show any right click options specified in the app's desktop file

        Args:
            app : The DockedApp
        """

        df_shortcut_1_action = self.dock_action_group.get_action("df_shortcut_1_action")
        df_shortcut_2_action = self.dock_action_group.get_action("df_shortcut_2_action")
        df_shortcut_3_action = self.dock_action_group.get_action("df_shortcut_3_action")
        df_shortcut_4_action = self.dock_action_group.get_action("df_shortcut_4_action")

        act_exists, act_name, act_cmd_line = app.get_rc_action(1)
        df_shortcut_1_action.set_visible(act_exists)
        if act_exists == True:
            df_shortcut_1_action.set_label(act_name)
            df_shortcut_1_action.set_icon_name(app.icon_name)
        
        act_exists, act_name, act_cmd_line = app.get_rc_action(2)
        df_shortcut_2_action.set_visible(act_exists)
        if act_exists == True:
            df_shortcut_2_action.set_label(act_name)
            df_shortcut_2_action.set_icon_name(app.icon_name)

        act_exists, act_name, act_cmd_line = app.get_rc_action(3)
        df_shortcut_3_action.set_visible(act_exists)
        if act_exists == True:
            df_shortcut_3_action.set_label(act_name)
            df_shortcut_3_action.set_icon_name(app.icon_name)

        act_exists, act_name, act_cmd_line = app.get_rc_action(4)
        df_shortcut_4_action.set_visible(act_exists)
        if act_exists == True:
            df_shortcut_4_action.set_label(act_name)
            df_shortcut_4_action.set_icon_name(app.icon_name)

        pin_action = self.dock_action_group.get_action("pin_action")
        unpin_action = self.dock_action_group.get_action("unpin_action")
        move_up_action = self.dock_action_group.get_action("move_up_action")
        move_down_action = self.dock_action_group.get_action("move_down_action")
        move_left_action = self.dock_action_group.get_action("move_left_action")
        move_right_action = self.dock_action_group.get_action("move_right_action")

        close_win_action = self.dock_action_group.get_action("close_win_action")
        close_win_action.set_visible(False)

        index = self.get_app_position_in_dock(app)
        pin_action.set_visible(not app.is_pinned)
        unpin_action.set_visible(app.is_pinned)

        orientation = self.applet.get_orient()

        if orientation == MatePanelApplet.AppletOrient.LEFT or \
           orientation == MatePanelApplet.AppletOrient.RIGHT:
            move_up_action.set_visible(index > 0)
            move_down_action.set_visible(index < (len(self.box.get_children()))-1)
            move_left_action.set_visible(False)
            move_right_action.set_visible(False)
            move_up_action.set_label("Move %s up the dock" %app.app_name)
            move_down_action.set_label("Move %s down the dock" %app.app_name)
        else:
            move_up_action.set_visible(False)
            move_down_action.set_visible(False)
            move_left_action.set_visible(index > 0)
            move_right_action.set_visible(index < (len(self.box.get_children()))-1)
            move_left_action.set_label("Move %s to the left on the dock" %app.app_name)
            move_right_action.set_label("Move %s to the right on the dock" %app.app_name)

        if pin_action.is_visible():
            pin_action.set_label("Pin %s to the dock" %app.app_name)
        else:
            unpin_action.set_label("Unpin %s from the dock" %app.app_name)

        # set the actions for selecting specific windows

        num_win = app.get_num_windows()
        if num_win == 1:
            close_win_action.set_label("Close %s" %app.app_name)
        else:
            close_win_action.set_label("Close all windows")

        if num_win > 0:
            close_win_action.set_visible(True)

        ccl_action = self.dock_action_group.get_action("ccl_action")
        ccl_action.set_visible(not app.has_desktop_file())

    def setup_menu(self):
        """Set up the actions and right click menu for the applet
        """

        # actions named df_shortcut_<x>_action are used for implementing shortcuts/actions
        # specified in an app's .desktop file

        self.dock_action_group = Gtk.ActionGroup("DockActions")
        self.dock_action_group.add_actions([
                            ("df_shortcut_1_action", None,
                             "df_shortcut_1_action", None, "df_shortcut_1_action",\
                             self.df_shortcut_1), \
                            ("df_shortcut_2_action", None,
                             "df_shortcut_2_action", None, "df_shortcut_2_action",\
                             self.df_shortcut_2), \
                            ("df_shortcut_3_action", None,
                             "df_shortcut_3_action", None, "df_shortcut_3_action",\
                             self.df_shortcut_3), \
                            ("df_shortcut_4_action", None,
                             "df_shortcut_4_action", None, "df_shortcut_4_action",\
                             self.df_shortcut_4), \
                             ("pin_action", Gtk.STOCK_ADD, \
                             "_Pin app to the dock", None, "Pin app to the dock", \
                             self.pin_app), \
                             ("unpin_action", Gtk.STOCK_REMOVE, \
                             "_Unpin app from the dock", None, "Unpin app from the dock", \
                             self.unpin_app), \
                             ("move_up_action", Gtk.STOCK_GO_UP,\
                             "Move app _up the dock", None, "Move app up the dock", \
                             self.move_app_up), \
                             ("move_down_action", Gtk.STOCK_GO_DOWN, \
                             "Move app _down the dock", None, "Move app down the dock", \
                             self.move_app_down), \
                             ("move_left_action", Gtk.STOCK_GO_BACK,\
                             "Move app _left in the dock", None, "Move app left in the dock",\
                             self.move_app_up), \
                             ("move_right_action", Gtk.STOCK_GO_FORWARD, \
                             "Move app _right in the dock", None, "Move app right in the dock",\
                             self.move_app_down), \
                             ("prefs_action", Gtk.STOCK_PREFERENCES, \
                             "Dock P_references", None, "Dock Preferences", \
                             self.show_prefs_win), \
                             ("ccl_action", Gtk.STOCK_EXECUTE, \
                             "Create custo_m launcher for this app", None, "Create custom launcher for this app", \
                             self.show_ccl_win), \
                             ("about_action", Gtk.STOCK_ABOUT, \
                             "About...", None, "About...", self.show_about_win), \
                             ("close_win_action", Gtk.STOCK_CLOSE, \
                              "_Close", None, "Close", self.close_win) \
                             ])

        menu_xml = '<menuitem name="df_shortcut_1_action" action="df_shortcut_1_action"/><separator/>'
        menu_xml += '<menuitem name="df_shortcut_2_action" action="df_shortcut_2_action"/><separator/>'
        menu_xml += '<menuitem name="df_shortcut_3_action" action="df_shortcut_3_action"/><separator/>'
        menu_xml += '<menuitem name="df_shortcut_4_action" action="df_shortcut_4_action"/><separator/>'
        menu_xml += '<menuitem name="close_win" action="close_win_action"/><separator/>'
        menu_xml += '<menuitem name="move_up" action="move_up_action"/>'
        menu_xml += '<menuitem name="move_down" action="move_down_action"/>'
        menu_xml += '<menuitem name="move_left" action="move_left_action"/>'
        menu_xml += '<menuitem name="move_right" action="move_right_action"/>'
        menu_xml += '<separator/><menuitem name="Pin" action="pin_action"/>'
        menu_xml += '<menuitem name="Unpin" action="unpin_action"/><separator/>'
        menu_xml += '<menuitem name="Preferences" action="prefs_action"/>'
        menu_xml += '<menuitem name="Create custom launcher" action="ccl_action"/>'
        menu_xml += '<menuitem name="About" action="about_action"/><separator/>'

        self.applet.setup_menu(menu_xml, self.dock_action_group)

    def df_shortcut_1(self, data=None):
        """Perform the app's 1st .desktop file specified shortcut/action
        """

        if self.right_clicked_app is not None:
            self.right_clicked_app.run_rc_action(1)

    def df_shortcut_2(self, data=None):
        """Perform the app's 1st .desktop file specified shortcut/action
        """

        if self.right_clicked_app is not None:
            self.right_clicked_app.run_rc_action(2)

    def df_shortcut_3(self, data=None):
        """Perform the app's 1st .desktop file specified shortcut/action
        """

        if self.right_clicked_app is not None:
            self.right_clicked_app.run_rc_action(3)

    def df_shortcut_4(self, data=None):
        """Perform the app's 1st .desktop file specified shortcut/action
        """

        if self.right_clicked_app is not None:
            self.right_clicked_app.run_rc_action(4)

    def unpin_app(self, data=None):
        """Unpin the right clicked app from the dock.

        Unpin the app and update the dock settings.

        If the app is not running, remove it from the dock also
        """

        if self.right_clicked_app is not None:
            self.right_clicked_app.is_pinned = False
            self.write_settings()
            if not self.right_clicked_app.is_running():
                self.remove_app_from_dock(self.right_clicked_app)
                self.right_clicked_app = None

    def pin_app(self, data=None):
        """Pin the right clicked app to the dock.

        Pin the app and update the dock settings"""

        if self.right_clicked_app is not None:
            self.right_clicked_app.is_pinned = True
            self.write_settings()

    def get_app_position_in_dock(self, app):
        """ Get the position of a specified app in the dock.

        Args : app - A DockedApp

        Returns : the index of the app, or -1 if it wasn't found
        """

        index = 0
        for app_da in self.box.get_children():
            if app_da == app.drawing_area:
                return index
            index += 1

        return -1

    def move_app_up(self, data=None):
        """ Move the right clicked app up one position on the dock (or left if the
            panel is on the top or bottom of the screen).

        Moves the app and then recaculates the minimize location for it's windows.

        Writes the dock settings once all is done.
        """

        if self.right_clicked_app is not None:

            index = self.get_app_position_in_dock(self.right_clicked_app)
            if index > 0:

                # we need to move the app both in self.applist and self.box
                self.box.reorder_child(self.right_clicked_app.drawing_area, index-1)

                app = self.app_list[index-1]
                self.app_list[index-1] = self.app_list[index]
                self.app_list[index] = app

                # recalculate the minimize targets for each app
                self.app_list[index-1].set_icon_geometry()
                self.app_list[index].set_icon_geometry()

                self.write_settings()

    def move_app_down(self, data=None):
        """ Move the right clicked app down one position on the dock (or right if the
            panel is on the top or bottom of the screen).

        Moves the app and then recaculates the minimize location for it's windows.

        Writes the dock settings once all is done.
        """

        if self.right_clicked_app is not None:

            index = self.get_app_position_in_dock(self.right_clicked_app)
            if index < len(self.box.get_children()) -1:

                # we need to move the app both in self.applist and self.box
                self.box.reorder_child(self.right_clicked_app.drawing_area, index+1)

                app = self.app_list[index+1]
                self.app_list[index+1] = self.app_list[index]
                self.app_list[index] = app

                # recalculate the minimize targets for each app
                self.app_list[index+1].set_icon_geometry()
                self.app_list[index].set_icon_geometry()

                self.write_settings()

    def show_prefs_win(self, data=None):
        """ Show the preferences window.

        If, necessary create the window and register a callback for the 'ok' button
        press

        If the window has already been shown, just show it again.
        """

        if self.prefs_win is None:
            self.prefs_win = dock_prefs.DockPrefsWindow(self.prefs_win_ok_cb)
            self.prefs_win.set_indicator(self.indicator)
            self.prefs_win.set_multi_ind(self.multi_ind)
            self.prefs_win.set_show_unpinned_apps_on_all_ws(self.show_all_apps)
            self.prefs_win.set_click_restore_last_active(self.click_restore_last_active)
        else:
            self.prefs_win.show_all()

    def show_about_win(self, data=None):
        """ Show the About window.

        If, necessary create the window and show it.

        If the window has already been shown, just show it again.
        """
        if self.about_win is None:
            self.about_win = dock_about.AboutWindow()

        self.about_win.show_all()

    def prefs_win_ok_cb(self, widget, event):
        """ Callback for the 'ok' button on the preferences window.

        If the preferences have been changed then:
            write the new settings
            redraw each running app in app_list with the new indicator type

        Args:
            widget - the button the caused the event
            event - the event args
        """

        if (self.indicator != self.prefs_win.get_indicator_type()) or \
           (self.multi_ind != self.prefs_win.get_multi_ind()) or \
           (self.show_all_apps != self.prefs_win.get_show_unpinned_apps_on_all_ws()) or \
           (self.click_restore_last_active != self.prefs_win.get_click_restore_last_active()):

            self.indicator = self.prefs_win.get_indicator_type()
            self.multi_ind = self.prefs_win.get_multi_ind()
            self.show_all_apps = self.prefs_win.get_show_unpinned_apps_on_all_ws()
            self.click_restore_last_active = self.prefs_win.get_click_restore_last_active()
            self.write_settings()
            # redraw everything here
            for app in self.app_list:
                app.set_indicator(self.indicator)
                app.set_multi_ind(self.multi_ind)
                if app.is_running():
                    app.queue_draw()
            self.show_or_hide_app_icons()

        self.prefs_win.hide()

    def show_ccl_win(self, data=None):
        """ Show the create custom launcher window.

        If, necessary create the window and register a callback for the 'ok' button
        press

        If the window has already been shown, clear all of the fields
        before showing it
        """

        if self.ccl_win is None:
            self.ccl_win = dock_custom_launcher.DockCLWindow(self.ccl_win_ok_cb)
        else:
            self.ccl_win.set_default_values()

        self.ccl_win.name = self.right_clicked_app.app_name.strip()
        self.ccl_win.wm_class = self.right_clicked_app.wm_class_name
        self.ccl_win.show_all()

    def ccl_win_ok_cb(self, widget, event):
        """ Callback for the 'ok' button on the create custom launcher window.

        Check to ensure that all required fields (icon, launcher name and command) have been 
        entered and display an error dialog if not.

        If all required fields have been entered, use the info from the window to create a 
        .desktop file in ~/.local/share/applications

        The .desktop file will be named mda_<launcher name>.desktop - the initial
        'mda_' will allow the applet to search for and priorities self created
        .desktop files over system created ones...

        Args:
            widget - the button the caused the event
            event - the event args
        """

        valid_launcher = False
        if self.ccl_win.name == "":
            error_text = "The name of the launcher has not been set"
        elif self.ccl_win.command == "":
            error_text = "The command of the launcher has not been set"
        elif self.ccl_win.icon_filename == "":
            error_text = "The icon of the launcher has not been set"
        else:
            valid_launcher = True

        if valid_launcher == False:
            md = Gtk.MessageDialog(None, Gtk.DialogFlags.MODAL, Gtk.MessageType.ERROR, 
                                   Gtk.ButtonsType.OK,
                                   None)
            md.set_markup ('<span size="x-large"><b>Cannot create launcher</b></span>')
            md.format_secondary_text(error_text)
            md.run()
            md.destroy()
            return

        else:
            self.ccl_win.hide()

            # the gnome developer docs at 
            # https://developer.gnome.org/integration-guide/stable/desktop-files.html.en
            # state that .desktop filenames should not contain spaces, so....
            dfname = self.ccl_win.name.replace(" ", "-")

            dfname = os.path.expanduser("~/.local/share/applications/mda-%s.desktop" %dfname)

            dfile = open(dfname, "w")
            dfile.write("[Desktop Entry]\n")
            dfile.write("Name=%s\n" %self.ccl_win.name)
            dfile.write("Type=Application\n")
            dfile.write("Comment=%s\n" %self.ccl_win.comment)
            dfile.write("Exec=%s\n" %self.ccl_win.command)
            dfile.write("Icon=%s\n" %self.ccl_win.icon_filename)
            dfile.write("StartupWMClass=%s\n" %self.ccl_win.wm_class)

            # Code below can be uncommented if adding terminal apps to the dock ever
            # becomes a needed thing
            #term_app = "%s" %self.ccl_win.is_terminal_app
            #dfile.write("Terminal=%s\n" %term_app.lower())
    
            # we don't want this launcher displayed in the MATe menu 
            dfile.write("NoDisplay=true\n")

            dfile.close()            

            # create a docked app from the .desktop we just created and add it to the dock
            dock_app = docked_app.DockedApp()
            dock_app.desktop_file = dfname
            dock_app.read_info_from_desktop_file()
            dock_app.is_pinned = True
            dock_app.applet_win = self.applet.window
            dock_app.applet_orient = self.applet.get_orient()
            dock_app.set_indicator(self.indicator)
            dock_app.set_multi_ind(self.multi_ind)

            size = self.applet.get_size()
            self.set_app_icon(dock_app, size)
            self.app_list.append(dock_app)
            self.add_app(dock_app)
            self.show_or_hide_app_icons()
            self.write_settings()
       
    def show_win(self, win_no):
        """
        Bring the specified window number of the right clicked app to the front

        Args:
            win_no - the window number, starting at 1

        """

        win_list = self.right_clicked_app.get_wnck_windows()
        wnck_win = win_list[win_no-1]
        wnck_win.activate(0)

    def close_win(self, data=None):
        """Close all windows for the right clicked app"""

        win_list = self.right_clicked_app.get_wnck_windows()
        for wnck_win in win_list:
            wnck_win.close(0) # have to send 0 as the event time because we have
                              # no event time to send

    def icon_theme_changed(self, icontheme):
        """ Callback for when the Gtk icon theme changes

        Load the new icon set
        Iterate through each app in self.app_list and get it to reload it's icon
    """

        self.icontheme.rescan_if_needed()

        size = self.applet.get_size()
        for app in self.app_list:
            self.set_app_icon(app, size)

    def copy_wnck_info_to_app(self, app_from_dock, app_from_wnck, wnck_window):
        """Copy info from wnck into a docked applet

        If the wnck app pid is already present in the docked app, just
        copy the windows xids that are not in the docked app

        If the wnck app pid is not present, copy all of the the app_info
        """

        if app_from_dock.wnck_class is None:
            app_from_dock.wnck_class = app_from_wnck.wnck_class
        app_from_dock.set_app_name(app_from_wnck.app_name)
        if app_from_dock.wm_class_name == "":
            app_from_dock.wm_class_name = app_from_wnck.wm_class_name

        for wai in app_from_wnck.app_info:
            # look for a process in the docked app with an identical pid

            existing_pid = False
            for dai in app_from_dock.app_info:

                # different wnck_apps for a single app can share the same pid
                # so just check the wnck_apps for equivalency
                if dai.app == wai.app:
                    existing_pid = True

                if existing_pid == True:
                    # we need to merge info from the new details into the dock_app

                    for xid in wai.windows:
                        try:
                            unused_var = dai.windows.index(xid)
                            #if we get here, the window was found, so there's no
                            #need to do anything else

                        except ValueError:
                            # if we get here, the window wasn't found so it needs to be added
                            dai.windows.append(xid)

                    break

            if existing_pid == False:
                # add the info for the new process
                app_from_dock.app_info.append(wai)

    def find_desktop_file (self, df_name):
        """ Find the full filename of a specified .desktop file

        Search the following directories (and their subdirectories) for
        the specified filename
            /usr/share/applications
            /usr/local/share/applications
            ~/.local/share/applications

        Args : 
            df_name : the name of the .desktop file e.g. pluma.desktop. The
                      .desktop extension must be included

        Returns:
            The full filename (path + filename) of the desktop file if it exists
            or "" otherwise
        """

        srch_dirs = ["/usr/share/applications/", \
                     "/usr/local/share/applications/", \
                     os.path.expanduser("~/.local/share/applications/")]

        for srch_dir in srch_dirs:
            for the_dir, dir_list, file_list in os.walk(srch_dir):
                try:
                    unused_var = file_list.index(df_name)

                    #if we get here the file is found
                    the_name = os.path.join(the_dir, df_name)
                    return the_name

                except ValueError:
                    pass

        return ""

    def setup_app_list(self):
        """Setup the list of docked apps.

        First, read the list of pinned apps from the settings and add them to the app list

        Then iterate through the running apps, and then either:
            if this is a non-pinned app add it to app list
            if this is a pinned app, integrate the running app info with the pinned app details
            already set up

        Also, set up event handlers allowing us keep track of window open and close events
        and active window change events
        """

        self.app_list = []

        pinned_apps = self.settings.get_value("pinned-apps").unpack()

        # the settings contain a list of .desktop files, so we need to find and read each
        # file
        for pinned_app in pinned_apps:
            dock_app = docked_app.DockedApp()

            full_name = self.find_desktop_file(pinned_app)
            if full_name != "":
                dock_app.desktop_file = full_name
                if dock_app.read_info_from_desktop_file():
                    self.app_list.append(dock_app)

            dock_app.is_pinned = True

        self.wnck_screen.force_update()  # recommended per Wnck documentation

        for wnck_window in self.wnck_screen.get_windows():

            win_type = wnck_window.get_window_type()

            if ((win_type == Wnck.WindowType.NORMAL) or (win_type == Wnck.WindowType.DIALOG)) and \
                    wnck_window.is_skip_tasklist() == False:

                wnck_class = wnck_window.get_class_group()

                wnck_app = wnck_window.get_application()

                # setup a new docked app object with info from wnck
                dock_app = docked_app.DockedApp()
                dock_app.applet_win = self.applet.window
                dock_app.setup_from_wnck(wnck_app, wnck_class)

                # if this is a pinned app, merge the running app details with the item already
                # set up in app_list
                for app in self.app_list:
                    if app.desktop_file == dock_app.desktop_file:
                        # copy the running app's info to the pinned dock item
                        self.copy_wnck_info_to_app(app, dock_app, wnck_window)
                        
                        break
                else:
                    # it's not a pinned app so add it to the app list
                    self.app_list.append(dock_app)

        self.wnck_screen.connect("active-window-changed", self.active_win_changed)
        self.wnck_screen.connect("active-workspace-changed", self.active_workspace_changed)
        self.wnck_screen.connect("window-opened", self.window_opened)
        self.wnck_screen.connect("window_closed", self.window_closed)

    def active_workspace_changed(self, wnck_screen, previously_active_space):
        """ Event handler for the active workspace change even

        If we're only showing unpinned apps from the current workspace then
        hide all unpinned apps which do not have windows open on the new
        screen/workspace

        Arguments : 
            wnck_screen : the screen that emitted the event. Will be the same as
                          self.wnck_screen
            previously_active_space : the workspace that was previously active
            
        """

        if not self.show_all_apps:
            self.show_or_hide_app_icons()

    def active_win_changed(self, wnck_screen, prev_active_window):
        """Event handler for the window change event

        Remove the highlighted background from any prevously active app and redraw its icon

        Set the new app as active and redraw it with a highlighted background

        Args:
            wnck_screen :  the screen on which the event occurred - will be the same as
                        :  self.wnck_screen
            prev_active_window : the wnck_window that was previously active

        """

        for app in self.app_list:
            if app.is_active == True:
                app.is_active = False
                app.queue_draw()

        new_win = self.wnck_screen.get_active_window()

        if new_win is not None:
            new_cg = new_win.get_class_group()
            new_wm_class_name = new_cg.get_res_class()
            new_app = new_win.get_application()
            for app in self.app_list:
                 if app.wm_class_name == new_wm_class_name:
                     for aai in app.app_info:
                        if new_app == aai.app:
                            app.is_active = True
                            app.last_active_win = new_win
                            app.queue_draw()
                            break

    def window_opened(self, wnck_screen, wnck_window):
        """Event handler for the window_opened event

        If an aready running app has opened a new window, the window
        is added to to the running apps info

        If a newly lauched app is opening a new window, setup the app on the
        dock

        Args:
            wnck_screen : the screen on which the event occurred
            wnck_window : the newly opened window

        """

        # we're only interested when normal and dialog windows
        if (wnck_window.get_window_type() != Wnck.WindowType.NORMAL) and \
           (wnck_window.get_window_type() != Wnck.WindowType.DIALOG):
            return
        wnck_app = wnck_window.get_application()

        if not wnck_window.is_skip_tasklist():

            # setup a new DockedApp
            wnck_class = wnck_window.get_class_group()
            dock_app = docked_app.DockedApp()
            dock_app.applet_win = self.applet.window
            dock_app.applet_orient = self.applet.get_orient()
            dock_app.set_indicator(self.indicator)
            dock_app.set_multi_ind(self.multi_ind)
            got_desktop = dock_app.setup_from_wnck(wnck_app, wnck_class)

            # look for the app relating to the window in the dock
            in_dock = False
            for app in self.app_list:
                if got_desktop == True:
                    if app.desktop_file == dock_app.desktop_file:
                        in_dock = True
                # if we don't have the .desktop file then things get a little more
                # complicated
                elif app.has_wnck_app(wnck_app) or \
                     app.wnck_class == dock_app.wnck_class or \
                     app.wm_class_name.upper() == dock_app.wm_class_name.upper():
                         in_dock = True

                if in_dock == True:
                    # found it, so copy the running app's info to the pinned dock item
                    self.copy_wnck_info_to_app(app, dock_app, wnck_window)

                    # set the minimize target for the new window
                    app.set_icon_geometry()

                    # if the mouse pointer is over the app's dock icon, regenerate the list
                    # of right click menu items to take acount of the new window
                    if app.has_mouse:
                        self.set_actions_for_app(app)
                    break

            if in_dock == False:
                # append the app to the dock

                size = self.applet.get_size()
                self.set_app_icon(dock_app, size)
                self.app_list.append(dock_app)
                self.add_app(dock_app)
                self.show_or_hide_app_icons()

    def window_closed(self, wnck_screen, wnck_window):
        """Event handler for the window_closed event

        Find the app relating to the closed window.

        If it has no more open windows mark it as not running and
        redraw its icon without the running indicator.

        If the are open windows remaining, remove the closed window from
        the apps list of windows

        Args:
            wnck_screen : the screen on which the event occurred
            wnck_window : the closed window

        """


        # we're only interested in the closure of normal and dialog windows
        if (wnck_window.get_window_type() != Wnck.WindowType.NORMAL) and \
           (wnck_window.get_window_type() != Wnck.WindowType.DIALOG):
            return

        wnck_app = wnck_window.get_application()
        if wnck_app is None:

            # this always seems to be the case - so we need to find the app another
            # way - look through each of the running apps for the one which
            # has the closed window in it's window list

            # this is done by using xids - using wnck_windows in the app_info tuple
            # didn't seem to work very well

            xid = wnck_window.get_xid()
            for app in self.app_list:
                for aai in app.app_info:
                    try:
                        # a valueerror exception occurs if the window is not found
                        unused_var = aai.windows.index(xid)

                        # we've found the app so remove the window from it's list
                        aai.windows.remove(xid)
                        
                        do_redraw = False
                        
                        # if the app has no more open windows, mark it as closed
                        if len(aai.windows) == 0:
                            # there no more open windows for this process. Does the app
                            # have any other running processes ?
                            if len(app.app_info) == 1:
                                # No, it doesn't ////

                                app.app_info = []
                                if not app.is_pinned:

                                    #rmeove the app from the dock
                                    self.remove_app_from_dock(app)
                                else:
                                    app.is_active = False
                                    do_redraw = True
                            else:
                                # remove this processes info from docked app
                                app.app_info.remove(aai)
                                do_redraw = True
                        else:
                            do_redraw = True

                        # was the closed window was the last active window for the app ?
                        if app.last_active_win == wnck_window:
                            app.last_active_win = None

                        if do_redraw:
                            app.queue_draw()

                        if app.has_mouse:
                            self.set_actions_for_app(app)
                        break

                    except ValueError:
                        pass

    def show_or_hide_app_icons(self):
        """ If we're only showing unpinned apps from the current workspace then
            then show/hide as appropriate

            If we're showing unpinned apps from all workspaces then show them
            all

            Finally, recalculate all app minimization targets
        """

        if self.show_all_apps:
            for app in self.app_list:
                if not app.is_visible():
                    app.show_icon()
        else:
            cur_ws = self.wnck_screen.get_active_workspace()
            for app in self.app_list:
                if not app.is_pinned:
                    if app.has_windows_on_workspace(cur_ws):
                        app.show_icon()
                    else:
                        app.hide_icon()
   
        # recalculate all apps icon geometry
        for app in self.app_list:
            app.set_icon_geometry()

    def remove_app_from_dock(self, app):
        """Remove an app from the dock.

        Remove the app from the app_list

        Remove the app's drawing area from self.box

        Args:
            app : the app to be removed

        """

        self.app_list.remove(app)
        self.box.remove(app.drawing_area)

        app = None

    def set_app_icon(self, dock_app, size):
        """ Sets up an app's icon, scaling it to a specified size

        Select an appropriate icon size based on the specified size

        Load the app's icon, using a fallback STOCK_EXEC as a fallback

        Scale the icon to the specified size

        Args:
            dock_app : the DockedApp
            size : the required icon size in pixels
        """

        if size >= 56:
            icon_size = 64
            stock_size = Gtk.IconSize.DIALOG
        elif size >= 40:
            icon_size = 48
            stock_size = Gtk.IconSize.DIALOG
        elif size >= 28:
            icon_size = 32
            stock_size = Gtk.IconSize.DND
        elif size >= 20:
            icon_size = 24
            stock_size = Gtk.IconSize.LARGE_TOOLBAR
        else:
            icon_size = 16
            stock_size = Gtk.IconSize.BUTTON

        if self.icontheme.has_icon(dock_app.icon_name):

            icon_info = self.icontheme.choose_icon([dock_app.icon_name, None], icon_size, 0)
            dock_app.icon_filename = icon_info.get_filename()

            try:
                pixbuf = icon_info.load_icon()
            except GLib.GError:
                # default to a stock icon if we couldn't load the app icon
                pixbuf = self.applet.render_icon(Gtk.STOCK_EXECUTE, stock_size, None)
                dock_app.icon_filename = "STOCK_EXECUTE"

        else:
            # the default theme has no icon for the app, so there are a few things we
            # can do...
            #
            # 1 .. quick and dirty - check to see if the icon points to an actual file
            #                        or ...
            #                        look in /usr/share/pixmaps for an icon of any type with
            #                        the same name as the app
            #                        then ...
            #                        look in ~/.local/share/icons for an icon with the same name
            #                        and extension as the icon   
            #
            # 2 .. sloooow         - iterate through each installed icon theme and try to
            #                        find the app - not implement for now

            # the png method. look for lower and uppercased variations of the filename
            # and note that all files in /usr/share/pixmaps are .png

            icon_file = ""
            if os.path.isfile(dock_app.icon_name):
                pixbuf = GdkPixbuf.Pixbuf.new_from_file(dock_app.icon_name)
            else:
                icon_file = ""
                icon_name = os.path.splitext(dock_app.icon_name)[0] # remove any extension
                if os.path.isfile("/usr/share/pixmaps/%s.png" %icon_name):
                    icon_file = icon_name + ".png"
                elif os.path.isfile("/usr/share/pixmaps/%s.png" %icon_name.upper()):
                    icon_file = icon_name.upper() + ".png"
                elif os.path.isfile("/usr/share/pixmaps/%s.png" %icon_name.lower()):
                    icon_file = icon_name.lower() + ".png"

                if icon_file != "":
                    pixbuf = GdkPixbuf.Pixbuf.new_from_file("/usr/share/pixmaps/%s"%icon_file)
                else:
                    icon_file = os.path.expanduser("~/.local/share/icons/%s" %dock_app.icon_name)
                    if os.path.isfile(icon_file):
                        pixbuf= GdkPixbuf.Pixbuf.new_from_file(icon_file)
                    else:
                        pixbuf = self.applet.render_icon(Gtk.STOCK_EXECUTE, stock_size, None)
                        dock_app.icon_filename = "STOCK_EXECUTE"

        # scale the icon to the size that is available
        # Note - we're allowing for a 3 pixel border all around the icon, hence using size-6
        pixbuf = pixbuf.scale_simple(size -6, size - 6, \
                              GdkPixbuf.InterpType.BILINEAR)

        dock_app.set_drawing_area_size(size)
        dock_app.set_pixbuf(pixbuf)

    def add_app(self, dock_app):
        """
        Add an app's drawing area to the VBox/Hbox container

        Args:
            dock_app : the DockedApp
        """

        self.box.add(dock_app.drawing_area)


    def create_box(self, orientation):
        """Create a vertical or horizontal (depending on the applet orientation)
           box to contain the docked apps areas.

        Args:
            orientation : the applet orientation
        """

        if orientation == MatePanelApplet.AppletOrient.LEFT or \
           orientation == MatePanelApplet.AppletOrient.RIGHT:
            self.box = Gtk.VBox()
        else:
            self.box = Gtk.HBox()

        self.box.set_spacing(1)

    def setup_dock(self):
        """Setup the dock."

        Add all pinned apps to the dock

        Add all non-pinned running apps to the dock

        Setup all apps according to the applet size and orientation

        """


        # make sure the applet is correctly oriented
        orientation = self.applet.get_orient()
        self.create_box(orientation)

        # setup up pinned and non-pinned running apps
        self.setup_app_list()
        applet_size = self.applet.get_size()

        # add the apps to the dock
        for dock_app in self.app_list:
            dock_app.applet_orient = orientation
            dock_app.applet_win = self.applet.window
            self.set_app_icon(dock_app, applet_size)
            dock_app.set_indicator(self.indicator)
            dock_app.set_multi_ind(self.multi_ind)
            self.add_app(dock_app)

        self.show_or_hide_app_icons()

    def set_new_orientation(self, new_orient):
        """Change the dock applet to a new applet orientation

        Remove all app's drawing areas from the V/HBox

        Remove the V/HBox and create a new one according to the new orientation

        Add all of the app's drawing areas to the new V/HBox

        Set all of the apps to use the new orientations and recalculate all
        of their minimize targets

        Args:
            new_orient : the new applet orientation
        """

        for dock_app in self.app_list:
            self.box.remove(dock_app.drawing_area)

        self.applet.remove(self.box)
        self.box = None

        self.create_box(new_orient)

        for dock_app in self.app_list:
            self.box.add(dock_app.drawing_area)
            dock_app.set_icon_geometry()   # reset minimize target
            dock_app.applet_orient = new_orient


        self.applet.add(self.box)

    def set_app_minimise_targets(self):
        """ Set all docked apps to recalculate their minimise targets"""

        for app in self.app_list:
            app.set_icon_geometry()

    def get_app_at_mouse(self, mouse_x, mouse_y):
        """
        Find the app underneath the mouse cursor.

        Args:
            mouse_x : the x coord of the mouse
            mouse_y : the y coord of the mouse

        Returns:
            The app under the mouse, or None if one could not be found
        """

        for app in self.app_list:
            if app.is_visible():
                alloc = app.drawing_area.get_allocation()
                if (mouse_x >= alloc.x) and (mouse_x <= alloc.x + alloc.width):
                    if (mouse_y >= alloc.y) and (mouse_y <= alloc.y + alloc.height):
                        return app

        return None

    def reset_win_list_timer(self):
        """ Reset win_list timer

        If the timer is already instantiated, delete it.
        
        Start a new timer with the appropriate delay

        """

        if self.win_list_timer is not None:
            GObject.source_remove(self.win_list_timer)
        
        self.win_list_timer = GObject.timeout_add(self.win_list_delay, self.show_win_list)

    def stop_win_list_timer(self):
        """ Stop the win list timer
        """

        if self.win_list_timer is not None:
            GObject.source_remove(self.win_list_timer)
            self.win_list_timer = None

    def show_win_list(self):
        """ Show the the list of open windows for the currently highlighted app

        Get the currently highlighted app. If the highlighted app is not running 
        or a window list is already being displayed for it, or a user interaction
        has already dismissed the window list, then do nothing

        Otherwise, fill the window list, set the window position and set the
        screen areas where the mouse must remain or the window list will hide
        """

        panel_space = 5 # how many pixels away from the panel the window list will
                        # appear

        win_border = 15 # size of the border (in pixels) around the window list where
                        # the mouse must remain, outside of which the window list wil;
                        # hide

        highlighted_app = self.app_with_mouse 
        if (highlighted_app is None) or (highlighted_app.is_running == False):
            return
        
        if highlighted_app is not None:

            # we need to show to window list

            # first reset, the window list
            self.app_win_list.dismissed = True
            self.app_win_list.hide()
            self.app_win_list.clear_win_list()

            self.app_win_list.the_app = highlighted_app
            self.app_win_list.setup_list()
            self.app_win_list.clear_mouse_areas()

            # add the applet to the mouse areas
            applet_x, applet_y = self.applet.window.get_root_coords(0,0)
            applet_w, applet_h = self.applet.window.get_size()

            if applet_x < 0:
                applet_x = 0
            if applet_y < 0:
                applet_y = 0

            self.app_win_list.add_mouse_area (Gdk.Rectangle(applet_x, applet_y, applet_w, applet_h))
            
            # get the display resolution
            screen = self.app_win_list.get_screen()
            screen_w = screen.get_width()
            screen_h = screen.get_height()

            # work out where to place the window - adjacent to the panel and centered on the
            # highlighted dock app

            app_alloc = highlighted_app.drawing_area.get_allocation()
            aax, aay = self.applet.window.get_root_coords(app_alloc.x, app_alloc.y)
            self.app_win_list.realize()
            win_w, win_h = self.app_win_list.get_size()

            orientation = self.applet.get_orient()
            if orientation == MatePanelApplet.AppletOrient.RIGHT:
                centre_pos  = aay + app_alloc.height/2
                win_x = applet_w + panel_space
                win_y = centre_pos - (win_h/2)

                # adjust win_y in case we're off the top the screen...
                if win_y < panel_space:
                    win_y = panel_space 

                # adjust win_y if case the window list extends beyound the end of the panel ..
                if (win_y + win_h) > screen_h:
                    win_y = screen_h - win_h - panel_space

                # setup a new mouse area covering the window (minus a border) and extending
                # to the panel
                self.app_win_list.add_mouse_area(Gdk.Rectangle(applet_x, 
                                                               win_y - win_border ,
                                                               win_x +win_w + win_border, 
                                                               win_h + (2*win_border)))
                
            elif orientation == MatePanelApplet.AppletOrient.LEFT:
                centre_pos  = aay + app_alloc.height/2
                win_x = applet_x - panel_space - win_w
                win_y = centre_pos - (win_h/2)

                # adjust win_y in case we're off the top the screen...
                if win_y < panel_space:
                    win_y = panel_space 

                # adjust win_y if case the window list extends beyound the end of the panel ..
                if (win_y + win_h) > screen_h:
                    win_y = screen_h - win_h - panel_space

                # setup a new mouse area covering the window (minus a border) and extending
                # to the panel
                self.app_win_list.add_mouse_area(Gdk.Rectangle(win_x - win_border, 
                                                               win_y - win_border,
                                                               applet_x + applet_w, 
                                                               win_h + (2*win_border)))
               
            elif orientation == MatePanelApplet.AppletOrient.DOWN:
                centre_pos  = aax+ app_alloc.width/2
                win_x = centre_pos - (win_w / 2) 
                win_y = applet_h +  panel_space

                # adjust win_x in case we're off the left of the screen...
                if win_x < panel_space:
                    win_x = panel_space 

                # adjust win_x if case the window list extends beyond the end of the panel ..
                if (win_x + win_w) > screen_w:
                    win_x = screen_w - win_w - panel_space

                # setup a new mouse area covering the window (minus a border) and extending
                # to the panel
                self.app_win_list.add_mouse_area(Gdk.Rectangle(win_x - win_border, 
                                                               applet_y,
                                                               win_w + (2*win_border), 
                                                               win_y + win_h + win_border))
            else:
                centre_pos  = aax+ app_alloc.width/2
                win_x = centre_pos - (win_w / 2) 
                win_y = applet_y - panel_space - win_h

                # adjust win_x in case we're off the left of the screen...
                if win_x < panel_space:
                    win_x = panel_space 

                # adjust win_x if case the window list extends beyond the end of the panel ..
                if (win_x + win_w) > screen_w:
                    win_x = screen_w - win_w - panel_space

                # setup a new mouse area covering the window (minus a border) and extending
                # to the panel
                self.app_win_list.add_mouse_area(Gdk.Rectangle(win_x - win_border, 
                                                               win_y - win_border,
                                                               win_w + (2*win_border), 
                                                               applet_y  + applet_h))
            self.app_win_list.move (win_x, win_y)
            self.app_win_list.show_all()
            
            self.win_list_timer = None
            return False

    def hide_win_list(self):
        """ Hide the window list """

        if self.app_win_list is not None:
            self.app_win_list.hide()

    def minimize_or_restore_windows(self, app, event):
        """ Minimize or restore an app's windows in response to a left click of
            it's dock icon

        the action to perform (minimizing, moving workspace, activating)
        is decided as follows:
           if (the app's windows are all minimized) or 
               (the app s one or more unminimized window but is not the active app)
           then     
               restore the app's last active window or all windows (based on the
               user's settings). If the active window is on a  different workspace 
               then activate that workspace
           else:
               the app is currently the active app so all of the app 
               windows will be minimized
        
        but first, hide any app window list that is being shown and stop the 
        window list timer

        Args:
            app: the docked app whose windows are to be minimized or restored
            event : the mouse click event

        """

        self.stop_win_list_timer()
        self.hide_win_list()
        
        win_list = app.get_wnck_windows()

        restore_win = (not app.has_unminimized_windows()) or \
                          (app.has_unminimized_windows() and (app.is_active==False))
        if restore_win:
            last_active_win = app.last_active_win

            # the last active window may be set to None (e.g. if the app's active window has been closed
            # and no other window has been made active afterwards). Therefore, if there is no active last window
            # activate the app's first window
            if last_active_win is None:
                last_active_win = win_list[0]

            # if we're restoring all windows, do this now before we finally activate the last active window
            if self.click_restore_last_active == False:
                for window in win_list:
                    win_type = window.get_window_type()
                    if ((win_type == Wnck.WindowType.NORMAL) or \
                            (win_type == Wnck.WindowType.DIALOG)) and \
                            (not window.is_skip_tasklist()) and \
                            (window != last_active_win):
                        window.activate(event.time)
                        sleep(0.01)   # allow the window manager time to activate
                                      # the window
                                
                app.last_active_win = last_active_win
                        
            if last_active_win is not None:
                wnck_screen = last_active_win.get_screen()
                wnck_aws = wnck_screen.get_active_workspace()
                wnck_ws = last_active_win.get_workspace()

                if wnck_aws != wnck_ws:
                    wnck_ws.activate(event.time)
                    sleep(0.01)

                # rarely, the last active win does not end up as the active window if we
                # activate here, so instead a workaround which seems to do the trick
                # is use a timer as below
                GObject.timeout_add(20, win_activation_timer, [last_active_win, event.time+20])

        else:
            #minimize all windows and do the last active window last of all

            last_active_win = app.last_active_win

            for window in win_list:
                win_type = window.get_window_type()
                if ((win_type == Wnck.WindowType.NORMAL) or \
                     (win_type == Wnck.WindowType.DIALOG)) and \
                     (not window.is_skip_tasklist()) and \
                     (window != last_active_win):
                         window.minimize()
                         sleep(0.01)

            app.last_active_win = last_active_win
            if last_active_win is not None:
                last_active_win.minimize()
                sleep(0.01)

def win_activation_timer(args):
    """ Timer function to be called by GObject.timeout_add and which
        will activate a specified wnck window

    Args: 
        args - a tuple containing two items
               args[0] - the wnck window to activate
               args[1] - the event time we want to specfiy

    Returns:
        False - to cancel the timer
    """

    args[0].activate(args[1])
    sleep(0.01) 
    return (False)

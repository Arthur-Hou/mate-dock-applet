#!/usr/bin/env python3

"""Provide an application dock applet for the MATE panel

Create a Mate panel applet and handle events generated
by it

Note: Functionality for docked apps is provided in docked_app.py

      Function for the dock is provided in dock.py

"""

# Copyright (C) 1997-2003 Free Software Foundation, Inc.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; either version 2 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301, USA.
#
# Author:
#     Robin Thompson

import os
import sys
sys.path.insert(1, '@pythondir@')
from time import sleep

import gi
gi.require_version("Gtk", "2.0")
from gi.repository import Gtk
from gi.repository import MatePanelApplet
from gi.repository import Gdk
from gi.repository import Gio
from gi.repository import GObject

gi.require_version("Wnck", "1.0")
from gi.repository import Wnck

import xdg.DesktopEntry as DesktopEntry

import docked_app
import dock
from dock_win_list import DockWinList

from log_it import log_it as log_it

def applet_button_press(widget, event, the_dock):
    """Button press event for the applet

    Handle right button press events only

    Find the app that was right clicked and make a record of it

    Args:
        widget : the widget that was clicked
        event : the event args
        the_dock : the Dock object
    """

    # we don't get click events for the right mouse button presumably
    # because the panel hijacks them in order to produce the context menu
    # However, we do get button press event for the right mouse button,
    # so we can do what we need to do here ....
    if event.button == 3:
        #right click, so save the app that was clicked because
        # the_dock.app_with_mouse is going to be set to None when the
        # right click menu appears and we move the mouse over the menu to select
        # an option
        app = the_dock.get_app_at_mouse(event.x, event.y)
        the_dock.right_clicked_app = app

        # because the right click menu is about to be shown, we need to hide
        # the window list
        the_dock.hide_win_list()

def applet_button_release(widget, event, the_dock):
    """Button press event for the applet

    Handle left button release events only

    If the button is released over a non-running app, start the app

    If the button is released over a runnning app that isn't on the
    current workspace, change workspace

    If the button is released over a running app on the current workspace:
        if it is the active app minmize all of its windows
        Otherwise, restore them all

    Args:
        widget : the widget that registered the release event
        event : the event args
        the_dock : the Dock object

    """

    if event.button == 1:

        # hide the window list window 

        the_dock.hide_win_list()

        app = the_dock.get_app_at_mouse(event.x, event.y)
        if app is not None:

            # if the app is not running start the app
            # if the app is running and the shift key is being pressed, start another
            # instance of the app
            start_app = app.is_running() == False
            start_app = start_app | (event.state & Gdk.ModifierType.SHIFT_MASK) != 0
            if start_app:
                the_de = DesktopEntry.DesktopEntry(app.desktop_file)
                run_it = the_de.getExec()
                if run_it is not None:

                    # hack for Linux Mint:
                    # Mint has several shortcuts for starting caja so that it can
                    # be started in a specific directory e.g. home, /, etc
                    # However, the main caja.desktop is responsible for starting the
                    # user's desktop and this is the .desktop file the applet finds first.
                    # When the caja icon on the applet is clicked, caja is run as a desktop
                    # window and no new file browser appears.
                    # To get around this, we can simply check the command that is going to be
                    # run and change it so that a caja window opens in the user's home directory,
                    # which is the behaviour they'll probably be expecting....
                    if run_it == "/usr/bin/startcaja":
                        run_it = "caja"

                    # remove any command line arguments
                    if "%" in run_it:
                        i = run_it.rfind("%")
                        run_it = run_it[0:i-1]

                app_info = Gio.AppInfo.create_from_commandline(run_it,
                                                               None,
                                                               Gio.AppInfoCreateFlags.NONE)
                alc = Gdk.AppLaunchContext()
                alc.set_desktop(-1)                   # use default screen & desktop
                app_info.launch()
                # set the app icon pulsing
                throbber = docked_app.PulseTimer(app)

            else:
                # the action to perform (minimizing, moving workspace, activating)
                # is decided as follows:
                #   if (the app's windows are all minimized) or 
                #      (the app s one or more unminimized window but is not the active app)
                #   then     
                #       restore all windows and set the focus on the app's last active
                #       window. If the active window is on a different workspace then
                #       activate that workspace
                #   else:
                #       the app is currently the active app so all of the app 
                #       windows will be minimized

                win_list = app.get_wnck_windows()

                restore_all_win = (not app.has_unminimized_windows()) or \
                                  (app.has_unminimized_windows() and (app.is_active==False))

                if restore_all_win:
                    last_active_win = app.last_active_win
                    for window in win_list:
                        win_type = window.get_window_type()
                        if ((win_type == Wnck.WindowType.NORMAL) or \
                             (win_type == Wnck.WindowType.DIALOG)) and \
                             (not window.is_skip_tasklist()) and \
                             (window != last_active_win):
                                 window.activate(event.time)
                                 sleep(0.01)   # allow the window manager time to activate
                                               # the window

                    # finally, reactivate the apps last active window and it's workspace
                    # (if necessary)
                    app.last_active_win = last_active_win

                    if last_active_win is not None:
                        wnck_screen = last_active_win.get_screen()
                        wnck_aws = wnck_screen.get_active_workspace()
                        wnck_ws = last_active_win.get_workspace()

                        if wnck_aws != wnck_ws:
                            wnck_ws.activate(event.time)
                            sleep(0.01)

                        # rarely, the last active win does not end up as the active window if we
                        # activate here, so instead a workaround which seems to do the trick
                        # is use a timer as below
                        GObject.timeout_add(20, win_activation_timer, [last_active_win, event.time+20])

                else:
                    #minimize all windows and do the last active window last of all

                    last_active_win = app.last_active_win

                    for window in win_list:
                        win_type = window.get_window_type()
                        if ((win_type == Wnck.WindowType.NORMAL) or \
                             (win_type == Wnck.WindowType.DIALOG)) and \
                             (not window.is_skip_tasklist()) and \
                             (window != last_active_win):
                                 window.minimize()
                                 sleep(0.01)

                    app.last_active_win = last_active_win
                    if last_active_win is not None:
                        last_active_win.minimize()
                        sleep(0.01)

def win_activation_timer(args):
    """ Timer function to be called by GObject.timeout_add and which
        will activate a specified wnck window

    Args: 
        args - a tuple containing two items
               args[0] - the wnck window to activate
               args[1] - the event time we want to specfiy

    Returns:
        False - to cancel the timer
    """

    args[0].activate(args[1])
    sleep(0.01) 
    return (False)

def applet_enter_notify(widget, event, the_dock):
    """Enter notify event for the applet

    Brighten the icon of the app which the mouse is currently over

    If another app is currently brightened, darken it to normal

    Set up the right click menu for the dock based on the app which
    the mouse is currently over

    Start the timer for showing app window lists

    Args:
        widget : the widget that registered the event i.e. the applet
        event : the event args
        the_dock : the Dock object
    """

    # get the app underneath the mouse cursor
    app = the_dock.get_app_at_mouse(event.x, event.y)

    # if an app is currently highlighted, de-highlight it
    if the_dock.app_with_mouse is not None:

        the_dock.app_with_mouse.has_mouse = False
        the_dock.app_with_mouse.queue_draw()
        the_dock.app_with_mouse = None

    # highlight the app under the mouse cursor
    if app is not None:
        app.has_mouse = True
        app.queue_draw()
        the_dock.app_with_mouse = app

        # set up the available options for the app
        the_dock.set_actions_for_app(app)
    
        the_dock.reset_win_list_timer()

def applet_leave_notify(widget, event, the_dock):
    """Leave notifiy event handle for the applet

    Unbrighten any brightened app icon

    Args:
        widget : the widget that registered the event i.e. the applet
        event : the event args
        the_dock : the Dock object
    """

    if the_dock.app_with_mouse is not None:
        the_dock.app_with_mouse.has_mouse = False
        the_dock.app_with_mouse.queue_draw()
        the_dock.app_with_mouse = None

    the_dock.stop_win_list_timer()

def applet_motion_notify(widget, event, the_dock):
    """Motion notify event for the applet

    If the docked app under the mouse cursor does not have its icon
    brightened and another app has a brightened icon then darken the other app icon
    and reset the applet tooltip text

    Then, if the docked app under the mouse cursor does not have its icon
    brightened then brighten it and setup the applet right click menu

    Args:
        widget : the widget that registered the event i.e. the applet
        event : the event args
        the_dock : the Dock object
    """

    app = the_dock.get_app_at_mouse(event.x, event.y)

    if (the_dock.app_with_mouse is not None) and (the_dock.app_with_mouse != app):
        the_dock.app_with_mouse.has_mouse = False
        the_dock.app_with_mouse.queue_draw()

        widget.queue_draw()

        # because a new app is highlighted reset the window list timer and hide any 
        # currently open window list
        the_dock.hide_win_list()
        the_dock.reset_win_list_timer()

    if (app is not None):

        # reset the window list timer
        the_dock.reset_win_list_timer()
       
        if app.has_mouse == False:
            app.has_mouse = True
            app.queue_draw()
            the_dock.app_with_mouse = app
            the_dock.set_actions_for_app(app)

def applet_query_tooltip(widget, x, y, keyboard_mode, tooltip, the_dock):
    """Handler for the query_has_tooltip event

    Don't show a tooltip, but instead use this event as a trigger to displaya list 
    of the currently highlighted app's windows

    Args:
        widget, the widget the registered the event, i.e. the applet
        x - x position of the mouse relative to window.widget
        y - y position of the mouse relative to window.widget
        keyboard_mode - True if the tooltip was triggered from the keyboard
        tooltip - the tooltip object that will be show

    Returns: 
        False - to prevent a tooltip from being shown
    """

    return False   
    # what we need to do....
    # 
    # if the tooltip window is already being shown for the currrent docked app
    #       exit
    # else
    #       clear the list
    #
    # set up the window list and realize the window
    # set the window position (adjacent to the dock and centered on the current docked app)
    # show the window

    # (all of the above should be done by methods of the Dock object in dock.py)
    #
    # start a timer which periodically monitors the mouse coords. When the mouse is not:
    #           over the dock
    #           in the space between the dock and the window list
    #           with a set distance of the window list (e.g. 15 pixels)
    # then hide the window list and stop the timer
    # 
    # when a window is selected from the window list, close the window list and
    # delete the timer

#    win_list.move(x-15, y-10)

    #win_list.move(x,y)
    print ("tooltip query at %s %s" %(x, y))
    
    the_dock.show_winlist()
    return False

def applet_change_orient(applet, orient, the_dock):
    """Handler for applet change orientation event

    Set the dock to the new orientation and re-show the applet

    Args:
        widget : the widget that registered the event i.e. the applet
        event : the event args
        the_dock : the Dock object
    """

    the_dock.set_new_orientation(orient)
    the_dock.applet.show_all()
    the_dock.show_or_hide_app_icons()

def applet_change_size(applet, size, the_dock):
    """Handler for the applet change size event

    Resize the icon and recalculate the minimize location of each app in the dock

    Args:
        widget : the widget that registered the event i.e. the applet
        event : the event args
        the_dock : the Dock object
    """

    for app in the_dock.app_list:
        the_dock.set_app_icon(app, size)
        app.set_icon_geometry()


def applet_fill(applet):
    """
    Create the applet

    Register the events that we're interested in getting events for and
    connect event handlers for them

    Create a dock and add it V/HBox to the applet


    Args:
        applet : the applet
    """

    os.chdir (os.path.expanduser("~"))
    applet.set_events(applet.get_events() | Gdk.EventMask.BUTTON_PRESS_MASK \
                       | Gdk.EventMask.BUTTON_RELEASE_MASK \
                       | Gdk.EventMask.POINTER_MOTION_MASK \
                       | Gdk.EventMask.KEY_PRESS_MASK \
                       | Gdk.EventMask.KEY_RELEASE_MASK \
                       | Gdk.EventMask.STRUCTURE_MASK)
    
    the_dock = dock.Dock(applet)
    the_dock.setup_dock()

    applet.add(the_dock.box)
    applet.show_all()

    applet.connect("enter-notify-event", applet_enter_notify, the_dock)
    applet.connect("leave-notify-event", applet_leave_notify, the_dock)
    applet.connect("motion-notify-event", applet_motion_notify, the_dock)
    applet.connect("button-press-event", applet_button_press, the_dock)
    applet.connect("button-release-event", applet_button_release, the_dock)
    applet.connect("query-tooltip", applet_query_tooltip, the_dock)
    applet.connect("change-orient", applet_change_orient, the_dock)
    applet.connect("change-size", applet_change_size, the_dock)

    applet.set_background_widget(applet) # hack for panel transparency


def applet_factory(applet, iid, data):
    """Factory routine called when an applet needs to be created

    Create a dock applet if necessary

    Args:
        applet : the applet
        iid    : the id of the applet that needs to be created
    Returns:
        True if we created a dock applet, False otherwise
    """

    if iid != "DockApplet":
        return False

    applet_fill(applet)

    return True


MatePanelApplet.Applet.factory_main("DockAppletFactory", True,
                                    MatePanelApplet.Applet.__gtype__,
                                    applet_factory, None)

def main():
    """Main function.

    Debugging code can go here
    """
    pass

if __name__ == "__main__":
    main()
